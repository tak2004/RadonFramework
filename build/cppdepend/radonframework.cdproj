<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<NDepend IsCProject="false" AppName="Radon framework" Platform="DotNet">
  <OutputDir KeepXmlFiles="False">.\CppDependOut</OutputDir>
  <Projects>
    <Name>..\win64\RadonFramework.sln</Name>
  </Projects>
  <FrameworkProjects />
  <Dirs />
  <Report Kind="0" SectionsEnabled="45055" XslPath="" Flags="261632" />
  <BuildComparisonSetting ProjectMode="DontCompare" BuildMode="MostRecentAnalysisResultAvailable" ProjectFileToCompareWith="" BuildFileToCompareWith="" NDaysAgo="1" FocusOnRecentRulesViolations="False" />
  <BaselineInUISetting ProjectMode="DontCompare" BuildMode="MostRecentAnalysisResultAvailable" ProjectFileToCompareWith="" BuildFileToCompareWith="" NDaysAgo="1" FocusOnRecentRulesViolations="False" />
  <CoverageFiles CoverageDir="" UncoverableAttribute="" />
  <Plugins Plugin="true" Vera="true" Modernize="true">
    <LoadedPlugins>
      <ActivatedPlugin PluginName="Visual Studio Analyzer" />
    </LoadedPlugins>
  </Plugins>
  <TrendMetrics UseCustomLog="False" LogRecurrence="3" LogLabel="2" UseCustomDir="False" CustomDir="">
    <Chart Name="Lines of Code" ShowInReport="True">
      <Serie MetricName="# Lines of Code" MetricUnit="Loc" Color="#FF00BFFF" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="# Lines of Code (NotMyCode)" MetricUnit="Loc" Color="#FFA9A9A9" ChartType="Area" ScaleExp="0" />
      <Serie MetricName="# Lines of Comments" MetricUnit="Lines" Color="#FF008000" ChartType="Line" ScaleExp="0" />
    </Chart>
    <Chart Name="Rules Violated" ShowInReport="True">
      <Serie MetricName="# Rules" MetricUnit="Rules" Color="#FF66CDAA" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="# Rules Violated" MetricUnit="Rules" Color="#FFFF8C00" ChartType="Area" ScaleExp="0" />
      <Serie MetricName="# Critical Rules Violated" MetricUnit="Rules" Color="#FFFF0000" ChartType="Area" ScaleExp="0" />
    </Chart>
    <Chart Name="Rules Violations" ShowInReport="True">
      <Serie MetricName="# Rules Violations" MetricUnit="Violations" Color="#FFFF8C00" ChartType="Area" ScaleExp="0" />
      <Serie MetricName="# Critical Rules Violations" MetricUnit="Violations" Color="#FFFF0000" ChartType="Area" ScaleExp="0" />
    </Chart>
    <Chart Name="Max" ShowInReport="True">
      <Serie MetricName="Max Cyclomatic Complexity for Methods" MetricUnit="Paths" Color="#FFFF0000" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Max Cyclomatic Complexity for Types" MetricUnit="Paths" Color="#FFFF0000" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Max # Lines of Code for Methods (JustMyCode)" MetricUnit="LoC" Color="#FF0000FF" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Max # of Methods for Types" MetricUnit="Methods" Color="#FF32CD32" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Max Nesting Depth for Methods" MetricUnit="Scopes" Color="#FFFFD700" ChartType="Line" ScaleExp="0" />
    </Chart>
    <Chart Name="Average" ShowInReport="True">
      <Serie MetricName="Average Cyclomatic Complexity for Methods" MetricUnit="Paths" Color="#FFFF0000" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Average Cyclomatic Complexity for Types" MetricUnit="Paths" Color="#FFFF0000" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Average # Lines of Code for Methods" MetricUnit="LoC" Color="#FF0000FF" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Average # Methods for Types" MetricUnit="Methods" Color="#FF32CD32" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="Average Nesting Depth for Methods" MetricUnit="Scopes" Color="#FFFFD700" ChartType="Line" ScaleExp="0" />
    </Chart>
    <Chart Name="Third-Party Usage" ShowInReport="True">
      <Serie MetricName="# Third-Party Types Used" MetricUnit="Types" Color="#FF0000FF" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="# Third-Party Methods Used" MetricUnit="Methods" Color="#FFFF0000" ChartType="Line" ScaleExp="0" />
      <Serie MetricName="# Third-Party Projects Used" MetricUnit="Projects" Color="#FF646464" ChartType="Line" ScaleExp="1" />
      <Serie MetricName="# Third-Party Namespaces Used" MetricUnit="Namespaces" Color="#FF32CD32" ChartType="Line" ScaleExp="1" />
      <Serie MetricName="# Third-Party Fields Used" MetricUnit="Fields" Color="#FFFFD700" ChartType="Line" ScaleExp="1" />
    </Chart>
  </TrendMetrics>
  <HistoricAnalysisResult PersistRecurrence="3" UseCustomDir="False" CustomDir="" />
  <SourceFileRebasing FromPath="" ToPath="" />
  <PathVariables />
  <RuleFiles />
  <ProjectRules AreActive="True" /><Queries>
    <Group Name="Code Quality" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Types too big - critical</Name>
warnif count > 0 from t in JustMyCode.Types where 
   t.NbLinesOfCode > 500 && !t.IsGlobal
   orderby t.NbLinesOfCode descending
select new { t, t.NbLinesOfCode,
                t.NbMethods, t.NbFields }


//<Description>
// This rule matches types with more than 500 lines of code.
//
// Types where *NbLinesOfCode > 500* are extremely complex 
// to develop and maintain.
// See the definition of the NbLinesOfCode metric here 
// http://www.cppdepend.com/Metrics.aspx#NbLinesOfCode
//
// Maybe you are facing the **God Class** phenomenon:
// A **God Class** is a class that controls way too many other classes 
// in the system and has grown beyond all logic to become 
// *The Class That Does Everything*.
//</Description>

//<HowToFix>
// Types with many lines of code
// should be split in a group of smaller types.
// 
// To refactor a *God Class* you'll need patience, 
// and you might even need to recreate everything from scratch.
// Here are a few advices:
//
// • Think before pulling out methods: on what data does this method operate? 
// What responsibility does it have?
//
// • Try to maintain the interface of the god class at first 
// and delegate calls to the new extracted classes. 
// In the end the god class should be a pure facade without own logic.
// Then you can keep it for convenience 
// or throw it away and start to use the new classes only.
//
// • Unit Tests can help: write tests for each method before extracting it 
// to ensure you don't break functionality.
//</HowToFix>

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Methods too complex - critical</Name>
warnif count > 0 from m in JustMyCode.Methods where 
  m.CyclomaticComplexity > 20 && 
  m.NestingDepth > 5
  orderby m.CyclomaticComplexity descending,
          m.NestingDepth descending
select new { m, m.CyclomaticComplexity, m.NestingDepth }


//<Description>
// This rule matches methods where *CyclomaticComplexity* > 30 
// or *ILCyclomaticComplexity* > 60
// or *ILNestingDepth* > 6.
// Such method is typically hard to understand and maintain.
//
// Maybe you are facing the **God Method** phenomenon.
// A "God Method" is a method that does way too many processes in the system 
// and has grown beyond all logic to become *The Method That Does Everything*.
// When need for new processes increases suddenly some programmers realize: 
// why should I create a new method for each processe if I can only add an *if*.
//
// See the definition of the *CyclomaticComplexity* metric here:
// http://www.cppdepend.com/Metrics.aspx#CC
//
// See the definition of the NestingDepth metric here 
// http://www.cppdepend.com/Metrics.aspx#NestingDepth
//</Description>

//<HowToFix>
// A large and complex method should be split in smaller methods, 
// or even one or several classes can be created for that.
//
// During this process it is important to question the scope of each
// variable local to the method. This can be an indication if
// such local variable will become an instance field of the newly created class(es).
//
// Large *switch…case* structures might be refactored through the help
// of a set of types that implement a common interface, the interface polymorphism
// playing the role of the *switch cases tests*.
//
// Unit Tests can help: write tests for each method before extracting it 
// to ensure you don't break functionality.
//</HowToFix>



]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Methods with too many parameters - critical</Name>
warnif count > 0 from m in JustMyCode.Methods where 
  m.NbParameters > 8
  orderby m.NbParameters descending
select new { m, m.NbParameters }


//<Description>
// This rule matches methods with more than 8 parameters.
// Such method is painful to call and might degrade performance.
// See the definition of the *NbParameters* metric here: 
// http://www.cppdepend.com/Metrics.aspx#NbParameters
//</Description>

//<HowToFix>
// More properties/fields can be added to the declaring type to 
// handle numerous states. An alternative is to provide 
// a class or a structure dedicated to handle arguments passing.
//</HowToFix>


]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Quick summary of methods to refactor</Name>
warnif count > 0 from m in JustMyCode.Methods where 
                                    // Code Metrics' definitions
  m.NbLinesOfCode > 30 ||           // http://www.cppdepend.com/Metrics.aspx#NbLinesOfCode
  m.MaxNestedLoop > 3 ||       // http://www.cppdepend.com/Metrics.aspx#NbILInstructions
  m.CyclomaticComplexity > 20 ||    // http://www.cppdepend.com/Metrics.aspx#CC
  m.NestingDepth > 5 ||           // http://www.cppdepend.com/Metrics.aspx#ILNestingDepth
  m.NbParameters > 5 ||             // http://www.cppdepend.com/Metrics.aspx#NbParameters
  m.NbVariables > 8 ||              // http://www.cppdepend.com/Metrics.aspx#NbVariables
  m.NbOverloads > 6                 // http://www.cppdepend.com/Metrics.aspx#NbOverloads

select new { m, m.NbLinesOfCode, m.MaxNestedLoop, m.CyclomaticComplexity, 
              m.NestingDepth, 
             m.NbParameters, m.NbVariables, m.NbOverloads } 
             
//<Description>
// Methods matched by this rule somehow violate 
// one or several basic quality principles,
// whether it is too large (too many *lines of code*), 
// too complex (too many *if*, *switch case*, loops…)
// has too many variables, too many parameters
// or has too many overloads.
//</Description>

//<HowToFix>
// To refactor such method and increase code quality and maintainability,
// certainly you'll have to split the method into several smaller methods
// or even create one or several classes to implement the logic.
//
// During this process it is important to question the scope of each
// variable local to the method. This can be an indication if
// such local variable will become an instance field of the newly created class(es).
//
// Large *switch…case* structures might be refactored through the help
// of a set of types that implement a common interface, the interface polymorphism
// playing the role of the *switch cases tests*.
//
// Unit Tests can help: write tests for each method before extracting it 
// to ensure you don't break functionality.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods too big</Name>
warnif count > 0 from m in JustMyCode.Methods where 
   m.NbLinesOfCode > 30 
   orderby m.NbLinesOfCode descending
           
select new { m, m.NbLinesOfCode}

//<Description>
// This rule matches methods where *NbLinesOfCode > 30* or 
// (commented per default) *NbILInstructions > 200*.
// Such method can be hard to understand and maintain.
//
// However rules like *Methods too complex* or *Methods with too many variables*
// might be more relevant to detect *painful to maintain* methods, 
// because complexity is more related to numbers of *if*, 
// *switch case*, loops… than to just number of lines. 
//
// See the definition of the *NbLinesOfCode* metric here 
// http://www.cppdepend.com/Metrics.aspx#NbLinesOfCode
//</Description>

//<HowToFix>
// Usually too big methods should be split in smaller methods.
//
// But long methods with no branch conditions, that typically initialize some data,
// are not necessarily a problem to maintain nor to test, and might not need 
// refactoring.
//</HowToFix>

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods too complex</Name>
warnif count > 0 from m in JustMyCode.Methods where 
  m.CyclomaticComplexity > 20 ||
  m.MaxNestedLoop > 3 ||
  m.NestingDepth > 5
  orderby m.CyclomaticComplexity descending,
          m.MaxNestedLoop descending,
          m.NestingDepth descending
select new { m, m.CyclomaticComplexity, 
                m.MaxNestedLoop,
                m.NestingDepth  }

// Methods where CyclomaticComplexity > 20 
// or MaxNestedLoop > 40
// or NestingDepth > 4
// are hard to understand and maintain
// and should be split in smaller methods.
// See the definition of the complexity metrics here:
// http://www.cppdepend.com/Metrics.aspx#CC
// http://www.cppdepend.com/Metrics.aspx#NestingDepth

//<Description>
// This rule matches methods where *CyclomaticComplexity > 20* 
// or *ILCyclomaticComplexity > 40*
// or *ILNestingDepth > 4*.
// Such method is typically hard to understand and maintain.
//
// See the definition of the *CyclomaticComplexity* metric here:
// http://www.cppdepend.com/Metrics.aspx#CC
//
// See the definition of the *NestingDepth* metric here: 
// http://www.cppdepend.com/Metrics.aspx#NestingDepth
//</Description>

//<HowToFix>
// A large and complex method should be split in smaller methods, 
// or even one or several classes can be created for that.
//
// During this process it is important to question the scope of each
// variable local to the method. This can be an indication if
// such local variable will become an instance field of the newly created class(es).
//
// Large *switch…case* structures might be refactored through the help
// of a set of types that implement a common interface, the interface polymorphism
// playing the role of the *switch cases tests*.
//
// Unit Tests can help: write tests for each method before extracting it 
// to ensure you don't break functionality.
//</HowToFix>


]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods potentially poorly commented</Name>
warnif count > 0 from m in JustMyCode.Methods where 
  m.PercentageComment < 20 && 
  m.NbLinesOfCode > 20  
  orderby m.PercentageComment ascending
select new { m, m.PercentageComment, m.NbLinesOfCode, m.NbLinesOfComment }

//<Description>
// This rule matches methods with less than 20% of comment lines and that have 
// at least 20 lines of code. Such method might need to be more commented.
//
// See the definitions of the *Comments metric* here:
// http://www.cppdepend.com/Metrics.aspx#PercentageComment
// http://www.cppdepend.com/Metrics.aspx#NbLinesOfComment
//</Description>

//<HowToFix>
// Typically add more comment. But code commenting is subject to controversy.
// While poorly written and designed code would needs a lot of comment 
// to be understood, clean code doesn't need that much comment, especially
// if variables and methods are properly named and convey enough information.
// Unit-Test code can also play the role of code commenting.
//
// However, even when writing clean and well-tested code, one will have
// to write **hacks** at a point, usually to circumvent some API limitations or bugs.
// A hack is a non-trivial piece of code, that doesn't make sense at first glance,
// and that took time and web research to be found.
// In such situation comments must absolutely be used to express the intention, 
// the need for the hacks and the source where the solution has been found.
//</HowToFix>

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods with too many parameters</Name>
warnif count > 0 from m in JustMyCode.Methods where 
  m.NbParameters > 5 
  orderby m.NbParameters descending
select new { m, m.NbParameters }


//<Description>
// This rule matches methods with more than 5 parameters.
// Such method might be painful to call and might degrade performance.
// See the definition of the *NbParameters* metric here: 
// http://www.cppdepend.com/Metrics.aspx#NbParameters
//</Description>

//<HowToFix>
// More properties/fields can be added to the declaring type to 
// handle numerous states. An alternative is to provide 
// a class or a structure dedicated to handle arguments passing.
//</HowToFix>

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods with too many local variables</Name>
warnif count > 0 from m in JustMyCode.Methods where 
  m.NbVariables > 15 
  orderby m.NbVariables descending
select new { m, m.NbVariables }

//<Description>
// This rule matches methods with more than 15 variables.
//
// Methods where *NbVariables > 8* are hard to understand and maintain.
// Methods where *NbVariables > 15* are extremely complex and must be refactored. 
//
// See the definition of the *Nbvariables* metric here: 
// http://www.cppdepend.com/Metrics.aspx#Nbvariables
//</Description>

//<HowToFix>
// To refactor such method and increase code quality and maintainability,
// certainly you'll have to split the method into several smaller methods
// or even create one or several classes to implement the logic.
//
// During this process it is important to question the scope of each
// variable local to the method. This can be an indication if
// such local variable will become an instance field of the newly created class(es).
//</HowToFix>
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods with too many overloads</Name>
warnif count > 0 from m in JustMyCode.Methods where 
  m.NbOverloads > 6 && 
  !m.IsOperator // Don't report operator overload
  orderby m.NbOverloads descending
select new { m, m.NbOverloads }

//<Description>
// Method overloading is the ability to create multiple methods of the same name 
// with different implementations, and various set of parameters.
//
// This rule matches sets of method with more than 6 overloads.
//
// Such method set might be a problem to maintain 
// and provokes higher coupling than necessary.
//
// See the definition of the *NbOverloads* metric here 
// http://www.cppdepend.com/Metrics.aspx#NbOverloads
//</Description>

//<HowToFix>
// Typically the *too many overloads* phenomenon appears when an algorithm
// takes a various set of in-parameters. Each overload is presented as 
// a facility to provide a various set of in-parameters.
//
// The *too many overloads* phenomenon can also be a consequence of the usage
// of the **visitor design pattern** http://en.wikipedia.org/wiki/Visitor_pattern 
// since a method named *Visit()* must be provided for each sub type.
// In such situation there is no need for fix.
//</HowToFix>


]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types with too many methods</Name>
warnif count > 0 from t in JustMyCode.Types where 
  t.Methods.Count() > 20 && !t.IsGlobal
  orderby t.Methods.Count() descending
select new { t, t.InstanceMethods, t.StaticMethods }

// Types where Methods.Count() > 20 might be hard to 
// understand and maintain 
// but there might be cases where it is relevant 
// to have a high number of methods. 
// For example, the System.Windows.Forms.DataGridView 
// standard class has more than 1000 methods.

//<Description>
// This rule matches types with more than 20 methods. 
// Such type might be hard to understand and maintain.
//
// Notice that methods like constructors or property 
// and event accessors are not taken account.
//
// Having many methods for a type might be a symptom
// of too many responsibilities implemented.
//
// Maybe you are facing the **God Class** phenomenon:
// A **God Class** is a class that controls way too many other classes 
// in the system and has grown beyond all logic to become 
// *The Class That Does Everything*.
//</Description>

//<HowToFix>
// To refactor such type and increase code quality and maintainability,
// certainly you'll have to split the type into several smaller types
// that together, implement the same logic.
//
// To refactor a *God Class* you'll need patience, 
// and you might even need to recreate everything from scratch.
// Here are a few advices:
//
// • Think before pulling out methods:
// What responsibility does it have?
// Can you isolate some subsets of methods that operate on the same subsets of fields?
//
// • Try to maintain the interface of the god class at first 
// and delegate calls to the new extracted classes. 
// In the end the god class should be a pure facade without own logic.
// Then you can keep it for convenience 
// or throw it away and start to use the new classes only.
//
// • Unit Tests can help: write tests for each method before extracting it 
// to ensure you don't break functionality.
//</HowToFix>
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types with too many fields</Name>
warnif count > 0 from t in JustMyCode.Types where 
  t.Fields.Count() > 20 && 
  !t.IsEnumeration && !t.IsGlobal
  orderby t.Fields.Count() descending
select new { t, t.InstanceFields, t.StaticFields}

// Types where Fields.Count() > 20 and not IsEnumeration 
// might be hard to understand and maintain 
// but there might be cases where it is relevant 
// to have a high number of fields. 
// For example, the System.Windows.Forms.Control 
// standard class has more than 200 fields.
//<Description>
// This rule matches types with more than 20 fields. 
// Such type might be hard to understand and maintain.
//
// Notice that constant fields and static-readonly fields are not counted.
// Enumerations types are not counted also.
//
// Having many fields for a type might be a symptom
// of too many responsibilities implemented.
//</Description>

//<HowToFix>
// To refactor such type and increase code quality and maintainability,
// certainly you'll have to group subsets of fields into smaller types
// and dispatch the logic implemented into the methods 
// into these smaller types.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types with poor cohesion</Name>
warnif count > 0 from t in JustMyCode.Types where 
  (t.LCOM > 0.8 || t.LCOMHS > 0.95) && 
  t.NbFields > 10 && 
  t.NbMethods >10 && !t.IsGlobal
  orderby t.LCOM descending, t.LCOMHS descending
select new { t, t.LCOM, t.LCOMHS, 
                t.NbMethods, t.NbFields }


//<Description>
// This rule is based on the *LCOM code metric*,
// LCOM stands for **Lack Of Cohesion of Methods**.
// See the definition of the LCOM metric here 
// http://www.cppdepend.com/Metrics.aspx#LCOM
//
// The LCOM metric measures the fact that most methods are using most fields.
// A class is considered utterly cohesive (which is positive)
// if all its methods use all its instance fields.
//
// Only types with enough methods and fields are taken account to avoid bias.
// The LCOM takes its values in the range [0-1].
//
// This rule matches types with LCOM higher than 0.8.
// Such value generally pinpoints a **poorly cohesive class**.
//
// There are several LCOM metrics. 
// The LCOM HS (HS stands for Henderson-Sellers) takes its values in the range [0-2]. 
// A LCOM HS value higher than 1 should be considered alarming.
//</Description>

//<HowToFix>
// To refactor a poorly cohesive type and increase code quality and maintainability,
// certainly you'll have to split the type into several smaller and more cohesive types
// that together, implement the same logic.
//</HowToFix>


]]></Query>
    </Group>
    <Group Name="Code Quality Regression" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>From now, all methods added or refactored should respect basic quality principles</Name>
warnif count > 0 from m in JustMyCode.Methods where

// *** Only new or modified methods since Baseline for Comparison ***
 (m.WasAdded() || m.CodeWasChanged()) &&
 
// Low Quality methods// Metrics' definitions
(  m.NbLinesOfCode > 30 ||          // http://www.cppdepend.com/Metrics.aspx#NbLinesOfCode
   m.CyclomaticComplexity > 20 ||   // http://www.cppdepend.com/Metrics.aspx#CC
   m.MaxNestedLoop > 50 || 
   m.NestingDepth > 4 ||          // http://www.cppdepend.com/Metrics.aspx#ILNestingDepth
   m.NbParameters > 5 ||            // http://www.cppdepend.com/Metrics.aspx#NbParameters
   m.NbVariables > 8 ||             // http://www.cppdepend.com/Metrics.aspx#NbVariables
   m.NbOverloads > 6 )
select new { m, m.NbLinesOfCode, m.CyclomaticComplexity, 
             m.MaxNestedLoop, m.NestingDepth, 
             m.NbParameters, m.NbVariables, m.NbOverloads }  // http://www.cppdepend.com/Metrics.aspx#NbOverloads



//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
// This rule operates only on methods added or refactored since the baseline.
// The same effect can be obtained for any rules through:
// *Dashboard > Filter Recent Violations Only*.
// Doing so let's focus on code quality on recent changes only.
//
// Methods matched by this rule not only have been recently added or refactored,
// but also somehow violate one or several basic quality principles,
// whether it is too large (too many *lines of code*), 
// too complex (too many *if*, *switch case*, loops…)
// has too many variables, too many parameters
// or has too many overloads.
//</Description>

//<HowToFix>
// To refactor such method and increase code quality and maintainability,
// certainly you'll have to split the method into several smaller methods
// or even create one or several classes to implement the logic.
//
// During this process it is important to question the scope of each
// variable local to the method. This can be an indication if
// such local variable will become an instance field of the newly created class(es).
//
// Large *switch…case* structures might be refactored through the help
// of a set of types that implement a common interface, the interface polymorphism
// playing the role of the *switch cases tests*.
//
// Unit Tests can help: write tests for each method before extracting it 
// to ensure you don't break functionality.
//</HowToFix>
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>From now, all types added or refactored should respect basic quality principles</Name>
warnif count > 0 from t in JustMyCode.Types where

// *** Only match new or modified types since Baseline for Comparison ***
(t.WasAdded() || t.CodeWasChanged()) &&

// Eliminate interfaces, enumerations or types only with constant fields
// by making sure we are matching type with code.
t.NbLinesOfCode > 10 &&

// Low Quality types     Metrics' definitions are available here:
//     http://www.cppdepend.com/Metrics.aspx#MetricsOnTypes
(  // Types with too many methods
   t.NbMethods > 20 ||

   // Types with too many fields
   t.NbFields > 20 ||

   // Complex Types that use more than 50 other types
   t.NbTypesUsed > 50
)
select new { t, t.Methods, t.Fields, t.TypesUsed }


//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
// This rule operates only on types added or refactored since the baseline.
// The same effect can be obtained for any rules through:
// *Dashboard > Filter Recent Violations Only*.
// Doing so let's focus on code quality on recent changes only.
//
// Types matched by this rule not only have been recently added or refactored,
// but also somehow violate one or several basic quality principles,
// whether it has too many methods,
// it has too many fields,
// or is using too many types.
// Any of these criterions is often a symptom of a type with too many responsibilities.
//
// Notice that to count methods and fields, methods like constructors 
// or property and event accessors are not taken account.
// Notice that constants fields and static-readonly fields are not counted.
// Enumerations types are not counted also.
//</Description>

//<HowToFix>
// To refactor such type and increase code quality and maintainability,
// certainly you'll have to split the type into several smaller types
// that together, implement the same logic.
//</HowToFix>
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid decreasing code coverage by tests of types</Name>

warnif count > 0 
from t in JustMyCode.Types where
  t.IsPresentInBothBuilds() &&
  t.PercentageCoverage < t.OlderVersion().PercentageCoverage

select new { t,
    OldCov = t.OlderVersion().PercentageCoverage,
    NewCov = t.PercentageCoverage,
    OldLoc = t.OlderVersion().NbLinesOfCode,
    NewLoc = t.NbLinesOfCode,
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// This rule warns when a type code coverage ratio 
// decreased since the baseline. 
// This can mean that some tests have been removed
// but more often, this means that the type has been modified,
// and that changes haven't been covered by tests.
//
// To visualize changes in code, right-click a matched type and select:
//
// • Compare older and newer versions of source file
//
// • or Compare older and newer versions disassembled with Reflector
//</Description>

//<HowToFix>
// Write more unit-tests dedicated to cover changes in matched types
// not covered yet.
// If you find some *hard-to-test code*, it is certainly a sign that this code
// is not *well designed* and hence, needs refactoring.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types that used to be 100% covered but not anymore</Name>
        
warnif count > 0
from t in JustMyCode.Types where 
   t.IsPresentInBothBuilds() &&
   t.OlderVersion().PercentageCoverage == 100 &&
   t.PercentageCoverage < 100
let culpritMethods = t.Methods.Where(m => m.PercentageCoverage < 100)
select new {t, t.PercentageCoverage, culpritMethods }

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// Often covering 10% of remaining uncovered code of a class, 
// requires as much work as covering the first 90%.
// For this reason, typically teams estimate that 90% coverage is enough.
// However *untestable code* usually means *poorly written code* 
// which usually leads to *error prone code*.
// So it might be worth refactoring and making sure to cover the 10% remaining code
// **because most tricky bugs might come from this small portion of hard-to-test code**.
//
// Not all classes should be 100% covered by tests (like UI code can be hard to test)
// but you should make sure that most of the logic of your application
// is defined in some *easy-to-test classes*, 100% covered by tests.
//
// In this context, this rule warns when a type fully covered by tests is now only partially covered.
//</Description>

//<HowToFix>
// Write more unit-tests dedicated to cover code not covered anymore.
// If you find some *hard-to-test code*, it is certainly a sign that this code
// is not *well designed* and hence, needs refactoring.
//
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid making complex methods even more complex (Source CC)</Name>
// To visualize changes in code, right-click a matched method and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector

warnif count > 0 
from m in JustMyCode.Methods where
 !m.IsAbstract &&
  m.IsPresentInBothBuilds() &&
  m.CodeWasChanged()

let oldCC = m.OlderVersion().CyclomaticComplexity
where oldCC > 6 && m.CyclomaticComplexity > oldCC 

select new { m,
    oldCC ,
    newCC = m.CyclomaticComplexity ,
    oldLoc = m.OlderVersion().NbLinesOfCode,
    newLoc = m.NbLinesOfCode,
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// The method complexity is measured through the code metric
// *Cyclomatic Complexity* defined here:
// http://www.cppdepend.com/Metrics.aspx#CC
//
// This rule warns when a method already complex
// (i.e with *Cyclomatic Complexity* higher than 6)
// become even more complex since the baseline.
//
// To visualize changes in code, right-click a matched method and select:
//
// • Compare older and newer versions of source file
//
// • or Compare older and newer versions disassembled with Reflector
//</Description>

//<HowToFix>
// A large and complex method should be split in smaller methods, 
// or even one or several classes can be created for that.
//
// During this process it is important to question the scope of each
// variable local to the method. This can be an indication if
// such local variable will become an instance field of the newly created class(es).
//
// Large *switch…case* structures might be refactored through the help
// of a set of types that implement a common interface, the interface polymorphism
// playing the role of the *switch cases tests*.
//
// Unit Tests can help: write tests for each method before extracting it 
// to ensure you don't break functionality.
//</HowToFix>

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid making large methods even larger</Name>
// To visualize changes in code, right-click a matched method and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector

warnif count > 0 
from m in JustMyCode.Methods where
 !m.IsAbstract &&
  m.IsPresentInBothBuilds() &&
  m.CodeWasChanged() &&
 // Eliminate constructors from match, since they get larger
 // as soons as some fields initialization are added.
 !m.IsConstructor &&
 !m.IsDestructor

let oldLoc = m.OlderVersion().NbLinesOfCode
where oldLoc > 15 && m.NbLinesOfCode > oldLoc

select new { m,
    oldLoc,
    newLoc = m.NbLinesOfCode,
}
//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// This rule warns when a method already large
// (i.e with more than 15 lines of code)
// become even larger since the baseline.
//
// The method size is measured through the code metric
// *# Lines of Code* defined here:
// http://www.cppdepend.com/Metrics.aspx#NbLinesOfCode
//
// To visualize changes in code, right-click a matched method and select:
//
// • Compare older and newer versions of source file
//
// • or Compare older and newer versions disassembled with Reflector
//</Description>

//<HowToFix>
// Usually too big methods should be split in smaller methods.
//
// But long methods with no branch conditions, that typically initialize some data,
// are not necessarily a problem to maintain, and might not need refactoring.
//</HowToFix>
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid adding methods to a type that already had many methods</Name>
// To visualize changes in code, right-click a matched type and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector

warnif count > 0 
from t in JustMyCode.Types where
  t.IsPresentInBothBuilds() &&
  t.Methods.Count() > t.OlderVersion().Methods.Count() &&
  t.OlderVersion().Methods.Count() > 10

let newMethods = t.Methods.Where(m => m.WasAdded())
let removedMethods = t.OlderVersion().Methods.Where(m => m.WasRemoved())

select new { t,
             oldNbMethods = t.OlderVersion().NbMethods,
             newNbMethods = t.NbMethods,
             newMethods,
             removedMethods  }
             
             //<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// Types where number of methods is greater than 15 
// might be hard to understand and maintain.
//
// This rule lists types that already had more than 15 methods
// at the baseline time, and for which new methods have been added.
//
// Having many methods for a type might be a symptom
// of too many responsibilities implemented.
//
// Notice that constructors and methods generated by the compiler 
// are not taken account.
//</Description>

//<HowToFix>
// To refactor such type and increase code quality and maintainability,
// certainly you'll have to split the type into several smaller types
// that together, implement the same logic.
//</HowToFix>
             
             ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid transforming an immutable type into a mutable one</Name>

warnif count > 0
from t in Application.Types where
   t.IsPresentInBothBuilds() &&
   t.OlderVersion().IsImmutable &&
  !t.IsImmutable && 
  // Don't take account of immutable types transformed into static types (not deemed as immtable)
  !t.IsStatic
let culpritFields = t.Fields.Where(f => f.IsImmutable)
select new {
  t, 
  culpritFields
}

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// A type is considered as *immutable* if its instance fields
// cannot be modified once an instance has been built by a constructor.
//
// Being immutable has several fortunate consequences for a type.
// For example its instance objects can be used concurrently 
// from several threads without the need to synchronize accesses.
//
// Hence users of such type often rely on the fact that the type is immutable.
// If an immutable type becomes mutable, there are chances that this will break 
// users code.
// This is why this rule warns about such immutable type that become mutable.
//</Description>

//<HowToFix>
// If being immutable is an important property for a matched type,
// then the code must be refactored to preserve immutability.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid adding instance fields to a type that already had many instance fields</Name>
// To visualize changes in code, right-click a matched type and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector

warnif count > 0 
from t in JustMyCode.Types where
  t.IsPresentInBothBuilds() &&
 !t.IsStatic

let oldNbInstanceFields = t.OlderVersion().InstanceFields
let newNbInstanceFields = t.InstanceFields
where
  newNbInstanceFields.Count() > oldNbInstanceFields .Count() &&
  oldNbInstanceFields.Count() > 6

let newInstanceFields = t.InstanceFields.Where(f => f.WasAdded())

select new { t,
             oldCount = oldNbInstanceFields.Count() ,
             newCount = newNbInstanceFields.Count() ,
             newInstanceFields }
             //<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
//
// Types where number of fields is greater than 15 
// might be hard to understand and maintain.
//
// This rule lists types that already had more than 15 fields
// at the baseline time, and for which new fields have been added.
//
// Having many fields for a type might be a symptom
// of too many responsibilities implemented.
//
// Notice that *constants* fields and *static-readonly* fields are not taken account.
// Enumerations types are not taken account also.
//</Description>

//<HowToFix>
// To refactor such type and increase code quality and maintainability,
// certainly you'll have to group subsets of fields into smaller types
// and dispatch the logic implemented into the methods 
// into these smaller types.
//</HowToFix>
             
             ]]></Query>
    </Group>
    <Group Name="Object Oriented Design" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Base class should not use derivatives</Name>
warnif count > 0 
from baseClass in JustMyCode.Types
where baseClass.IsClass && baseClass.NbChildren > 0 // <-- for optimization!
let derivedClassesUsed = baseClass.DerivedTypes.UsedBy(baseClass)
where derivedClassesUsed.Count() > 0
select new { baseClass, derivedClassesUsed }

//<Description>
// In *Object-Oriented Programming*, the **open/closed principle** states:
// *software entities (components, classes, methods, etc.) should be open 
// for extension, but closed for modification*. 
// http://en.wikipedia.org/wiki/Open/closed_principle
//
// Hence a base class should be designed properly to make it easy to derive from,
// this is *extension*. But creating a new derived class, or modifying an
// existing one, shouldn't provoke any *modification* in the base class.
// And if a base class is using some derivative classes somehow, there
// are good chances that such *modification* will be needed.
//
// Extending the base class is not anymore a simple operation,
// this is not good design.
//</Description>

//<HowToFix>
// Understand the need for using derivatives, 
// then imagine a new design, and then refactor.
//
// Typically an algorithm in the base class needs to access something 
// from derived classes. You can try to encapsulate this access behind 
// an abstract or a virtual method.
//
// If you see in the base class some conditions on *typeof(DerivedClass)*
// not only *urgent refactoring* is needed. Such condition can easily 
// be replaced through an abstract or a virtual method.
//
// Sometime you'll see a base class that creates instance of some derived classes.
// In such situation, certainly using the *factory method pattern* 
// http://en.wikipedia.org/wiki/Factory_method_pattern
// or the *abstract factory pattern* 
// http://en.wikipedia.org/wiki/Abstract_factory_pattern
// will improve the design. 
//</HowToFix>
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Class shouldn't be too deep in inheritance tree</Name>
warnif count > 0 from t in JustMyCode.Types 
where t.IsClass
&& t.DepthOfInheritance >= 5

select new { t, 
                t.DepthOfInheritance } 

//<Description>
// This rule warns about classes having 3 or more base classes.
// Notice that third-party base classes are not counted
// because this rule is about your code design, not 
// third-party libraries consumed design.
//
// *In theory*, there is nothing wrong having a *long inheritance chain*,
// if the modelization has been well thought out,
// if each base class is a well-designed refinement of the domain.
//
// *In practice*, modeling properly a domain demands a lot of effort
// and experience and more often than not, a *long inheritance chain*
// is a sign of confused design, that will be hard to work with and maintain.
//</Description>

//<HowToFix>
// In *Object-Oriented Programming*, a well-known motto is
// **Favor Composition over Inheritance**.
//
// This is because *inheritance* comes with pitfalls.
// In general, the implementation of a derived class is very bound up with 
// the base class implementation. Also a base class exposes implementation
// details to its derived classes, that's why it's often said that 
// inheritance breaks encapsulation. 
//
// On the other hands, *Composition* favors binding with interfaces
// over binding with implementations. Hence, not only the encapsulation
// is preserved, but the design is clearer, because interfaces make it explicit
// and less coupled.
//
// Hence, to break a *long inheritance chain*, *Composition* is often
// a powerful way to enhance the design of the refactored underlying logic.
//
// You can also read: 
// http://en.wikipedia.org/wiki/Composition_over_inheritance and
// http://stackoverflow.com/questions/49002/prefer-composition-over-inheritance
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Constructor should not call a virtual methods</Name>

// Returns constructor of a non-sealed type calling virtual methods.
// In such a situation, if a derived class overrides the method,
// then the override method will be called before the derived constructor.
// This makes the class fragile to derive from.
//
// Violations reported can be solved by re-designing object initialisation
// or by marking the parent class as sealed, if possible.

warnif count > 0
from t in Application.Types where 
   t.IsClass &&
  !t.IsGeneratedByCompiler

from ctor in t.Constructors 
let virtualMethodsCalled = from mCalled in ctor.MethodsCalled
                           where mCalled.IsVirtual &&
                                (mCalled.ParentType == t ||
                                 t.DeriveFrom(mCalled.ParentType))
                           select mCalled
where virtualMethodsCalled.Count() > 0

select new { ctor , 
             virtualMethodsCalled, 
             // If there is no derived type, it might be 
             // an opportunity to mark t as sealed.
             t.DerivedTypes }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[//<Name>Avoid the Singleton pattern</Name>
warnif count > 0
from t in Application.Types
where !t.IsStatic && !t.IsAbstract && (t.IsClass || t.IsStructure)

// All ctors of a singleton are private
where t.Constructors.Where(ctor => !ctor.IsPrivate).Count() == 0

// A singleton contains one static field of its parent type, to reference the unique instance
let staticFieldInstances = t.StaticFields.WithFieldType(t)
where staticFieldInstances.Count() == 1
select new { t, staticFieldInstance = staticFieldInstances.First() }

// The Singleton pattern consists in syntactically enforcing that a class 
// has just one unique instance.
// At first glance, this pattern looks appealing and it is widely used.
// However, we discourage you from using singleton classes because experience
// shows that singletons often result in less testable and less maintainable code.
// More details available in these discussions:
//  http://codebetter.com/patricksmacchia/2011/05/04/back-to-basics-usage-of-static-members/
//  http://adamschepis.com/blog/2011/05/02/im-adam-and-im-a-recovering-singleton-addict/
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Don't assign static fields from instance methods</Name>
// Assigning static fields from instance methods leads to
// poorly maintainable and non thread-safe code.
// It is advised to assign static fields inline or from class constructor.
warnif count > 0
from f in Application.Fields where 
  f.IsStatic &&
 !f.IsGeneratedByCompiler && !f.IsGlobal
 
let assignedBy = f.MethodsAssigningMe.Where(m => !m.IsStatic && !m.IsGlobal)
where assignedBy .Count() > 0
select new { f, assignedBy }
//<Description>
// Assigning static fields from instance methods leads to
// poorly maintainable and non-thread-safe code.
//
// More discussion on the topic can be found here:
// http://codebetter.com/patricksmacchia/2011/05/04/back-to-basics-usage-of-static-members/
//</Description>

//<HowToFix>
// If the *static* field is just assigned once in the program
// lifetime, make sure to declare it as *readonly* and assign 
// it inline, or from the static constructor.
//
// In *Object-Oriented-Programming* the natural artifact 
// to hold states that can be modified is **instance fields**.
//
// Hence to fix violations of this rule, make sure to
// hold assignable states through *instance* fields, not
// through *static* fields.
//</HowToFix>


]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid Abstract Classes with too many methods</Name>
// An abstract class  should abstract a clear and well-defined concept.
// Such concept shoudln't be represented with too many methods and property getter.
warnif count > 0 from t in JustMyCode.Types where 
  t.IsAbstract
let methodsAndGetters = t.Methods
where methodsAndGetters.Count() > 10
select new { t, methodsAndGetters }]]></Query>
    </Group>
    <Group Name="Design" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Type should not have too many responsibilities</Name>
// Types using more than 8 different application namespaces 
// are considered as having too many responsabilities.
warnif count > 0 

from t in JustMyCode.Types 
let applicationTypesUsed = t.TypesUsed.ExceptThirdParty().ToList()
let applicationNamespacesUsed = applicationTypesUsed.ParentNamespaces().ToList()
where applicationNamespacesUsed.Count > 8

// Use an empiric formula to sort by degree of responsabilities
let responsabilitiesMetric = (10 * applicationNamespacesUsed.Count + applicationTypesUsed.Count)/10
orderby responsabilitiesMetric descending

select new { t, applicationNamespacesUsed, applicationTypesUsed, responsabilitiesMetric } 


]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Nested types should not be visible</Name>
warnif count > 0 from t in JustMyCode.Types where 
  t.IsNested && 
 !t.IsGeneratedByCompiler &&
 !t.IsPrivate 
select new { t, t.NbLinesOfCode, t.Visibility } 


// A nested type is a type declared within the 
// scope of another type. Nested types are useful 
// for encapsulating private implementation details 
// of the containing type. Used for this purpose, 
// nested types should not be externally visible. 
// Do not use externally visible nested types for 
// logical grouping or to avoid name collisions; 
// instead, use namespaces.]]></Query>
    </Group>
    <Group Name="Architecture and Layering" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid namespaces mutually dependent</Name>
warnif count > 0
// Foreach pair of namespace mutually dependent, this rule lists pairs.
// The pair { first, second } is formatted to show that first namespace shouldn't use the second namespace.
// The first/second order is inferred from the number of types used by each other.
// The first namespace is using less types of the second.
// It means that the first namespace is certainly at a lower level in the architecture, than the second.
// To explore the coupling between the two namespaces, you can export:
//  - typesOfFirstUsedBySecond to the vertical header of the dependency matrix
//  - typesOfSecondUsedByFirst to the horizontal header of the dependency matrix
//



// Optimization: restreint application Projects set
// If some namespaces are mutually dependent
//  - They must be declared in the same project
//  - The parent project must ContainsNamespaceDependencyCycle
from project in Application.Projects.Where(a => a.ContainsNamespaceDependencyCycle != null && a.ContainsNamespaceDependencyCycle.Value)

// hashset is used to avoid reporting both A <-> B and B <-> A
let hashset = new HashSet<INamespace>()

// Optimization: restreint namespaces set
// If a namespace doesn't have a Level value, it must be in a dependency cycle
// or it must be using directly or indirectly a dependency cycle.
let namespacesSuspect = project.ChildNamespaces.Where(n => n.Level == null && n.Name!="")

from nA in namespacesSuspect

// Select namespaces mutually dependent with nA
let unused = hashset.Add(nA) // Populate hashset
let namespacesMutuallyDependentWith_nA = nA.NamespacesUsed.Using(nA)
          .Except(hashset) // <-- avoid reporting both A <-> B and B <-> A 
where namespacesMutuallyDependentWith_nA.Count() > 0

from nB in namespacesMutuallyDependentWith_nA

// nA and nB are mutually dependent
// Select first the one that shouldn't use the other.
// The first namespace is inferred from the fact that it is using less types of the second.
let typesOfBUsedByA = nB.ChildTypes.UsedBy(nA)
let typesOfAUsedByB = nA.ChildTypes.UsedBy(nB)
let first = (typesOfBUsedByA.Count() > typesOfAUsedByB.Count()) ? nB : nA
let second = (first == nA) ? nB : nA
let typesOfFirstUsedBySecond = (first == nA) ? typesOfAUsedByB : typesOfBUsedByA
let typesOfSecondUsedByFirst = (first == nA) ? typesOfBUsedByA : typesOfAUsedByB
where typesOfFirstUsedBySecond.Count()>0 && typesOfSecondUsedByFirst.Count()>0
select new { first, shouldntUse = second, typesOfFirstUsedBySecond, typesOfSecondUsedByFirst }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid namespaces dependency cycles</Name>
warnif count > 0
// This query lists all application namespaces dependency cyles.
// Each row shows a different cycle, prefixed with a namespace entangled in the cycle.
//
// To browse a cycle on the dependency graph or the dependency matrix, just right click
// a cycle cell and export namespaces matched to the dependency graph or matrix!
//
// In the matrix, dependency cycles are represented with red squares and black cells.
// To browse easily dependency cycles, the Matrix comes with the option:
//   --> Display Direct and Indirect Dependencies
//



// Optimization: restreint application Projects set
// If some namespaces are mutually dependent
//  - They must be declared in the same project
//  - The parent project must ContainsNamespaceDependencyCycle
from project in Application.Projects
                 .Where(a => a.ContainsNamespaceDependencyCycle != null && 
                             a.ContainsNamespaceDependencyCycle.Value)

// Optimization: restreint namespaces set
// A namespace involved in a cycle necessarily have a null Level.
let namespacesSuspect = project.ChildNamespaces.Where(n => n.Level == null && n.Name!="")

// hashset is used to avoid iterating again on namespaces already caught in a cycle.
let hashset = new HashSet<INamespace>()


from suspect in namespacesSuspect
   // By commenting this line, the query matches all namespaces involved in a cycle.
   where !hashset.Contains(suspect)

   // Define 2 code metrics
   // - Namespaces depth of is using indirectly the suspect namespace.
   // - Namespaces depth of is used by the suspect namespace indirectly.
   // Note: for direct usage the depth is equal to 1.
   let namespacesUserDepth = namespacesSuspect.DepthOfIsUsing(suspect)
   let namespacesUsedDepth = namespacesSuspect.DepthOfIsUsedBy(suspect)

   // Select namespaces that are both using and used by namespaceSuspect
   let usersAndUsed = from n in namespacesSuspect where 
                         namespacesUserDepth[n] > 0 && 
                         namespacesUsedDepth[n] > 0 
                      select n

   where usersAndUsed.Count() > 0

   // Here we've found namespace(s) both using and used by the suspect namespace.
   // A cycle involving the suspect namespace is found!
   let cycle = usersAndUsed.Concat(new[] { suspect  })

   // Fill hashset with namespaces in the cycle.
   // .ToArray() is needed to force the iterating process.
   let unused1 = (from n in cycle let unused2 = hashset.Add(n) select n).ToArray()

select new { suspect, cycle }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Projects with poor cohesion (RelationalCohesion)</Name>
warnif count > 0 from a in Application.Projects where 
  a.NbTypes > 20 && // Relational Cohesion metrics is relevant only if there are several types 
  (a.RelationalCohesion < 1.5 || 
   a.RelationalCohesion > 4.0)
select new { a, a.NbTypes, a.RelationalCohesion }

// As classes inside an project should be strongly related, 
// the cohesion should be high. On the other hand, a value 
// which is too high may indicate over-coupling. A good range 
// for RelationalCohesion is 1.5 to 4.0.
// See the definition of the RelationalCohesion metric here 
// http://www.cppdepend.com/Metrics.aspx#RelationalCohesion]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Projects that don't satisfy the Abstractness/Instability principle</Name>
warnif percentage > 15 from a in Application.Projects where 
  a.NormDistFromMainSeq > 0.7 
  orderby a.NormDistFromMainSeq descending
select new { a, a.NormDistFromMainSeq }

// See the definition of the NormDistFromMainSeq metric here 
// http://www.cppdepend.com/Metrics.aspx#DitFromMainSeq]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Example of custom rule to check for dependency</Name>

// To define a rule that warns if a particular dependency exist or not, 
// from a code element A to a code element B
// A and B being an project Namespace Type Method or Field,
// A and B not necessarily two Projects or two Namespaces...
// you can first, right click the cell in the Dependency Matrix
// with B in row and A in column,
// or right-click the concerned arrow in the Dependency Graph
// from A to B, and choose to: 
// "Generate a code rule that warns if this dependency exists"
//
// The generated rule will look like the one below.
// It is now up to you to adapt this rule to check your needs.

warnif count > 0 from a in Projects
where 
a.IsUsing("Foo1.Foo2".AllowNoMatch().MatchNamespace()) &&
(a.Name == @"Foo3")
select new { a, a.NbLinesOfCode }
// the project Foo3
// shouldn't use directly 
// the namespace Foo3.Foo4
// because (TODO insert your reason)
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Higher cohesion - lower coupling</Name>
// It is deemed as a good software architecture practice to clearly separate
// 'abstract' namespaces containing only abstractions (interfaces, enumerations, delegates)
// from other 'concrete' namespaces, that contains classes and structures.
//
// Typically, the more concrete namespaces rely on abstract namespaces *only*,
// the more Decoupled is the architecture, and the more Cohesive are 
// classes inside concrete namespaces.
//
// The following code query, define sets of abstract and concrete namespaces
// and shows for each concrete namespaces, which concrete and abstract namespaces are used.
// 
// This query can be adapted to a rule, depending on how much you want
// your code architecture being decoupled.
//

let abstractNamespaces = JustMyCode.Namespaces.Where(
     n => n.ChildTypes.Where(t => !t.IsInterface && !t.IsEnumeration ).Count() == 0
).ToHashSet()

let concreteNamespaces = JustMyCode.Namespaces.Except(abstractNamespaces).ToHashSet()

from n in concreteNamespaces
let namespacesUsed = n.NamespacesUsed.ExceptThirdParty()
let concreteNamespacesUsed = namespacesUsed.Except(abstractNamespaces)
let abstractNamespacesUsed = namespacesUsed.Except(concreteNamespaces)
select new { n, concreteNamespacesUsed , abstractNamespacesUsed }]]></Query>
    </Group>
    <Group Name="CppCheck Queries" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>All CppCheck Violations</Name>
warnif count>0          
from issue in Issues  where issue.ToolName=="CppCheck"
select new { issue,issue.FilePath,issue.BeginLine }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most Classes violating CppCheck rules</Name>
(from t in Types where !t.IsGlobal && t.Issues.Where(i=>i.ToolName=="CppCheck").Count()>0
orderby t.Issues.Count() descending
select new { t,nbIssues=t.Issues.Count() }).Take(100)

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most Methods violating CppCheck rules</Name>
(from m in Methods where m.Issues.Where(i=>i.ToolName=="CppCheck").Count()>0
orderby m.Issues.Count() descending
select new { m,nbIssues=m.Issues.Count() }).Take(100)]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most Project violating CppCheck rules</Name>
(from p in Projects where p.Issues.Where(i=>i.ToolName=="CppCheck").Count()>0
orderby p.Issues.Count() descending
select new { p,nbIssues=p.Issues.Count() }).Take(5)]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most Recurrent CppCheck violations</Name>
let groups = Application.Issues.Where(i=>i.ToolName=="CppCheck").GroupBy(t => t.Type)

from g in groups
orderby g.Count() descending
select new { issue=g.FirstOrDefault(),count=g.Count() }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Popular Methods violating CppCheck rules</Name>
(from m in Methods where m.Issues.Where(i=>i.ToolName=="CppCheck").Count()>0
orderby m.MethodsCallingMe.Count() descending
select new { m,NbCallingMethods= m.MethodsCallingMe }).Take(100)]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Popular Classes violating CppCheck rules</Name>
from t in Types where !t.IsGlobal && t.Issues.Where(i=>i.ToolName=="CppCheck").Count()>0
orderby t.TypesUsingMe.Count() descending
select new { t,ClassesUsingMe= t.TypesUsingMe}]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>CppCheck Violation Famillies with Most violations </Name>
let groups = Application.Issues.Where(i=>i.ToolName=="CppCheck").GroupBy(t => t.IssueFamilly)

from g in groups
orderby g.Count() descending
select new { issue=g.FirstOrDefault(),count=g.Count() }]]></Query>
    </Group>
    <Group Name="Diagnostics Queries" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>All diagnostics</Name> 
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang"
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Preprocessor issues</Name>
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang" && issue.Type.Contains("_pp_")
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Cast issues</Name>
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang" && issue.Type.Contains("cast")
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Conversion Issues</Name>
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang" && issue.Type.Contains("conversion")
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Deprecated Usage</Name>
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang" && issue.Type.Contains("deprecated")
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Unused Symbols</Name>
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang" && issue.Type.Contains("unused")
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Switch Issues</Name>
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang" && (issue.Type.Contains("switch") || issue.Type.Contains("case"))
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Delete Issues</Name>
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang" && issue.Type.Contains("delete")
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Struct Issues</Name>
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang" && issue.Type.Contains("_struct")
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Enum Issues</Name>
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang" && issue.Type.Contains("_enum_")
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Template Issues</Name>
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang" && issue.Type.Contains("template")
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Comparison Issues</Name>
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang" && issue.Type.Contains("comparison")
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>OpenMP Issues</Name>
warnif count > 0
from issue in Issues  where issue.ToolName=="Clang" && issue.Type.Contains("_omp_")
select new { issue,issue.FilePath,issue.BeginLine }
        ]]></Query>
    </Group>
    <Group Name="Vera++ Queries" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>All Vera++ Violations</Name>
warnif count>0          
from issue in Issues  where issue.ToolName=="Vera++"
select new { issue,issue.FilePath,issue.BeginLine }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most Classes violating Vera++ rules</Name>
(from t in Types where !t.IsGlobal && t.Issues.Where(i=>i.ToolName=="Vera++").Count()>0
orderby t.Issues.Count() descending
select new { t,nbIssues=t.Issues.Count() }).Take(100)

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most Methods violating Vera++ rules</Name>
(from m in Methods where m.Issues.Where(i=>i.ToolName=="Vera++").Count()>0
orderby m.Issues.Count() descending
select new { m,nbIssues=m.Issues.Count() }).Take(100)]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most Project violating Vera++ rules</Name>
(from p in Projects where p.Issues.Where(i=>i.ToolName=="Vera++").Count()>0
orderby p.Issues.Count() descending
select new { p,nbIssues=p.Issues.Count() }).Take(5)]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most Recurrent Vera++ violations</Name>
let groups = Application.Issues.Where(i=>i.ToolName=="Vera++").GroupBy(t => t.Type)

from g in groups
orderby g.Count() descending
select new { issue=g.FirstOrDefault(),count=g.Count() }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Popular Methods violating Vera++ rules</Name>
(from m in Methods where m.Issues.Where(i=>i.ToolName=="Vera++").Count()>0
orderby m.MethodsCallingMe.Count() descending
select new { m,NbCallingMethods= m.MethodsCallingMe }).Take(100)]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Popular Classes violating Vera++ rules</Name>
from t in Types where !t.IsGlobal && t.Issues.Where(i=>i.ToolName=="Vera++").Count()>0
orderby t.TypesUsingMe.Count() descending
select new { t,ClassesUsingMe= t.TypesUsingMe}]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Vera++ Violation Famillies with Most violations </Name>
let groups = Application.Issues.Where(i=>i.ToolName=="Vera++").GroupBy(t => t.IssueFamilly)

from g in groups
orderby g.Count() descending
select new { issue=g.FirstOrDefault(),count=g.Count() }]]></Query>
    </Group>
    <Group Name="API Breaking Changes" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>API Breaking Changes: Types</Name>
// This rule warns if a publicly visible type is 
// not publicly visible anymore or if it has been removed.
// Such type can break the code of your clients.

warnif count > 0 from t in codeBase.OlderVersion().Application.Types
where t.IsPublic && 

     // The type has been removed and its parent project hasn't been removed ...
     ( (t.WasRemoved() && !t.ParentProject.WasRemoved()) ||

     // ... or the type is not publicly visible anymore
       !t.WasRemoved() && !t.NewerVersion().IsPublic)

select new { t,
             NewVisibility = (t.WasRemoved() ? " " : t.NewerVersion().Visibility.ToString()) }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>API Breaking Changes: Methods</Name>
// This rule warns if a publicly visible method is 
// not publicly visible anymore or if it has been removed.
// Such method can break the code of your clients.

warnif count > 0 from m in codeBase.OlderVersion().Application.Methods
where m.IsPublic && 

     // The method has been removed and its parent type hasn't been removed ...
     ( (m.WasRemoved() && !m.ParentType.WasRemoved()) ||

     // ... or the method is not publicly visible anymore
       !m.WasRemoved() && !m.NewerVersion().IsPublic)

select new { m,
             NewVisibility = (m.WasRemoved() ? " " : m.NewerVersion().Visibility.ToString()) }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>API Breaking Changes: Fields</Name>
// This rule warns if a publicly visible field is 
// not publicly visible anymore or if it has been removed.
// Such field can break the code of your clients.

warnif count > 0 from f in codeBase.OlderVersion().Application.Fields
where f.IsPublic &&

     // The field has been removed and its parent type hasn't been removed ...
     ( (f.WasRemoved() && !f.ParentType.WasRemoved()) ||

     // ... or the field is not publicly visible anymore
       !f.WasRemoved() && !f.NewerVersion().IsPublic)

select new { f,
             NewVisibility = (f.WasRemoved() ? " " : f.NewerVersion().Visibility.ToString()) }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>API Breaking Changes: Interfaces and Abstract Classes</Name>
// This rule warns if a publicly visible interface or abstract class 
// has been changed and contains new abstract methods or 
// if some abstract methods have been removed.
// This can break the code of clients 
// that implement such interface or derive from such abstract class.

warnif count > 0 from tNewer in Application.Types where 
 (tNewer.IsInterface || tNewer.IsClass && tNewer.IsAbstract) && 
  tNewer.IsPublic && 
  tNewer.IsPresentInBothBuilds()

let tOlder = tNewer.OlderVersion() where tOlder.IsPublic

let methodsRemoved = tOlder.Methods.Where(m => m.IsAbstract && m.WasRemoved())
let methodsAdded = tNewer.Methods.Where(m => m.IsAbstract && m.WasAdded())

where methodsAdded.Count() > 0 || methodsRemoved.Count() > 0
select new { tNewer, methodsAdded, methodsRemoved }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="True"><![CDATA[// <Name>Avoid transforming immutable types into mutable types</Name>

// Immutability is a strong property on a type.
// Breaking immutability can result in serious problem for an algorithm consummer
// that has been written taking account of the type immutability.

// To visualize changes in code, right-click a matched type and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector

warnif count > 0 
from t in Application.Types where
  t.IsPresentInBothBuilds() &&
 !t.IsStatic &&
 !t.IsImmutable && 
  t.OlderVersion().IsImmutable

let mutableFields = from f in t.InstanceFields where !f.IsImmutable select f

select new { t, mutableFields }

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>API: New publicly visible types</Name>
// List types that are new in the public surface of your Projects

from t in Application.Types
where t.IsPublic && 

     // The type has been removed and its parent project hasn't been removed ...
     ( (t.WasAdded() && !t.ParentProject.WasAdded()) ||

     // ... or the type existed but was not publicly visible
       !t.WasAdded() && !t.OlderVersion().IsPublic)

select new { t,
             OldVisibility = (t.WasAdded() ? " " : t.OlderVersion().Visibility.ToString()) }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>API: New publicly visible methods</Name>
// List methods that are new in the public surface of your Projects

from m in Application.Methods
where m.IsPublic && 

     // The method has been removed and its parent project hasn'm been removed ...
     ( (m.WasAdded() && !m.ParentType.WasAdded()) ||

     // ... or the t existed but was not publicly visible
       !m.WasAdded() && !m.OlderVersion().IsPublic)

select new { m,
             OldVisibility = (m.WasAdded() ? " " : m.OlderVersion().Visibility.ToString()) }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>API: New publicly visible fields</Name>
// List fields that are new in the public surface of your Projects

from f in Application.Fields
where f.IsPublic && 

     // The method has been removed and its parent project hasn'f been removed ...
     ( (f.WasAdded() && !f.ParentType.WasAdded()) ||

     // ... or the t existed but was not publicly visible
       !f.WasAdded() && !f.OlderVersion().IsPublic)

select new { f,
             OldVisibility = (f.WasAdded() ? " " : f.OlderVersion().Visibility.ToString()) }]]></Query>
    </Group>
    <Group Name="Code Diff Summary" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New Projects</Name>
from a in Application.Projects where a.WasAdded()
select new { a, a.NbLinesOfCode }

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Projects removed</Name>
from a in codeBase.OlderVersion().Application.Projects where a.WasRemoved()
select new { a, a.NbLinesOfCode }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Projects where code was changed</Name>
from a in Application.Projects where a.CodeWasChanged()
select new { a, a.NbLinesOfCode, 
             oldNbLinesOfCode = a.OlderVersion().NbLinesOfCode ,
             delta = (int) a.NbLinesOfCode - a.OlderVersion().NbLinesOfCode }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New namespaces</Name>
from n in Application.Namespaces where 
 !n.ParentProject.WasAdded() &&
  n.WasAdded()
select new { n, n.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces removed</Name>
from n in codeBase.OlderVersion().Application.Namespaces where 
 !n.ParentProject.WasRemoved() &&
  n.WasRemoved()
select new { n, n.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces where code was changed</Name>
from n in Application.Namespaces where n.CodeWasChanged()
select new { n, n.NbLinesOfCode, 
             oldNbLinesOfCode = n.OlderVersion().NbLinesOfCode ,
             delta = (int) n.NbLinesOfCode - n.OlderVersion().NbLinesOfCode }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New types</Name>
from t in Application.Types where 
 !t.ParentNamespace.WasAdded() &&
  t.WasAdded()
select new { t, t.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types removed</Name>
from t in codeBase.OlderVersion().Application.Types where 
 !t.ParentNamespace.WasRemoved() &&
  t.WasRemoved()
select new { t, t.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types where code was changed</Name>
// To visualize changes in code, right-click a matched type and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector

from t in Application.Types where t.CodeWasChanged() 
//select new { t, t.NbLinesOfCode }
select new { t, t.NbLinesOfCode, 
             oldNbLinesOfCode = t.OlderVersion().NbLinesOfCode ,
             delta = (int?) t.NbLinesOfCode - t.OlderVersion().NbLinesOfCode } 
/*from t in Application.Types where t.CodeWasChanged() && t.IsPresentInBothBuild
select new { t, t.NbLinesOfCode, 
             oldNbLinesOfCode = t.OlderVersion().NbLinesOfCode ,
             delta = (int) t.NbLinesOfCode - t.OlderVersion().NbLinesOfCode }*/]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Heuristic to find types moved from one namespace or project to another</Name>
let typesRemoved = codeBase.OlderVersion().Types.Where(t => t.WasRemoved())
let typesAdded = Types.Where(t => t.WasAdded())

from tMoved in typesAdded.Join(
   typesRemoved,
   t => t.Name,
   t => t.Name,
   (tNewer, tOlder) => new { tNewer, 
                             OlderParentNamespace = tOlder.ParentNamespace,
                             OlderParentproject = tOlder.ParentProject  } ) 
select tMoved]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types directly using one or several types changed</Name>
let typesChanged = Application.Types.Where(t => t.CodeWasChanged()).ToHashSet()

from t in JustMyCode.Types.UsingAny(typesChanged) where
  !t.CodeWasChanged() && 
  !t.WasAdded()
let typesChangedUsed = t.TypesUsed.Intersect(typesChanged) 
select new { t, typesChangedUsed }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types indirectly using one or several types changed</Name>
let typesChanged = Application.Types.Where(t => t.CodeWasChanged()).ToHashSet()

// 'depth' represents a code metric defined on types using
// directly or indirectly any type where code was changed.
let depth = JustMyCode.Types.DepthOfIsUsingAny(typesChanged) 

from t in depth.DefinitionDomain where
  !t.CodeWasChanged() && 
  !t.WasAdded()

let typesChangedDirectlyUsed = t.TypesUsed.Intersect(typesChanged) 
let depthOfUsingTypesChanged = depth[t]
orderby depthOfUsingTypesChanged 

select new { t, depthOfUsingTypesChanged, typesChangedDirectlyUsed }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New methods</Name>
from m in Application.Methods where 
 !m.ParentType.WasAdded() &&
  m.WasAdded()
select new { m, m.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods removed</Name>
from m in codeBase.OlderVersion().Application.Methods where 
 !m.ParentType.WasRemoved() &&
  m.WasRemoved()
select new { m, m.NbLinesOfCode }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods where code was changed</Name>
// To visualize changes in code, right-click a matched method and select:
//  - Compare older and newer versions of source file
//  - Compare older and newer versions disassembled with Reflector

from m in Application.Methods where m.CodeWasChanged()
select new { m, m.NbLinesOfCode, 
             oldNbLinesOfCode = m.OlderVersion().NbLinesOfCode ,
             delta = (int?) m.NbLinesOfCode - m.OlderVersion().NbLinesOfCode }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods directly calling one or several methods changed</Name>
let methodsChanged = Application.Methods.Where(m => m.CodeWasChanged()).ToHashSet()

from m in JustMyCode.Methods.UsingAny(methodsChanged ) where
  !m.CodeWasChanged() && 
  !m.WasAdded()
let methodsChangedCalled = m.MethodsCalled.Intersect(methodsChanged) 
select new { m, methodsChangedCalled }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods indirectly calling one or several methods changed</Name>
let methodsChanged = Application.Methods.Where(m => m.CodeWasChanged()).ToHashSet()

// 'depth' represents a code metric defined on methods using
// directly or indirectly any method where code was changed.
let depth = JustMyCode.Methods.DepthOfIsUsingAny(methodsChanged) 

from m in depth.DefinitionDomain where
  !m.CodeWasChanged() && 
  !m.WasAdded()

let methodsChangedDirectlyUsed = m.MethodsCalled.Intersect(methodsChanged) 
let depthOfUsingMethodsChanged = depth[m]
orderby depthOfUsingMethodsChanged 

select new { m, depthOfUsingMethodsChanged, methodsChangedDirectlyUsed }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>New fields</Name>
from f in Application.Fields where 
 !f.ParentType.WasAdded() &&
  f.WasAdded()
select new { f }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Fields removed</Name>
from f in codeBase.OlderVersion().Application.Fields where 
 !f.ParentType.WasRemoved() &&
  f.WasRemoved()
select new { f }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party types that were not used and that are now used</Name>
from t in ThirdParty.Types where t.IsUsedRecently()
select new { t, t.Methods, t.Fields } 
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party types that were used and that are not used anymore</Name>
from t in codeBase.OlderVersion().Types where t.IsNotUsedAnymore()
select new { t, t.Methods, t.Fields }  
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party methods that were not used and that are now used</Name>
from m in ThirdParty.Methods where 
  m.IsUsedRecently() &&
 !m.ParentType.IsUsedRecently()
select m]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party methods that were used and that are not used anymore</Name>
from m in codeBase.OlderVersion().Methods where 
  m.IsNotUsedAnymore() &&
 !m.ParentType.IsNotUsedAnymore()
select m]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party fields that were not used and that are now used</Name>
from f in ThirdParty.Fields where 
  f.IsUsedRecently() &&
 !f.ParentType.IsUsedRecently()
select f]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Third party fields that were used and that are not used anymore</Name>
from f in codeBase.OlderVersion().Fields where 
  f.IsNotUsedAnymore() &&
 !f.ParentType.IsNotUsedAnymore()
select f
]]></Query>
    </Group>
    <Group Name="Test and Code Coverage" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>C.R.A.P method code metric</Name>

warnif count > 0
from m in JustMyCode.Methods

// Don't match too short methods
where m.NbLinesOfCode > 10

let CC = m.CyclomaticComplexity
let uncov = (100 - m.PercentageCoverage) / 100f
let CRAP = (CC * CC * uncov * uncov * uncov) + CC
where CRAP != null && CRAP > 30
orderby CRAP descending, m.NbLinesOfCode descending
select new { m, CRAP, CC, uncoveredPercentage = uncov*100, m.NbLinesOfCode }

//<Description>
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// **Change Risk Analyzer and Predictor** (i.e. CRAP) is a code metric
// that helps in pinpointing overly complex and untested code.
// Is has been first defined here: 
// http://www.artima.com/weblogs/viewpost.jsp?thread=215899
//
// The Formula is:  **CRAP(m) = CC(m)^2 * (1 – cov(m)/100)^3 + CC(m)**
//
// • where *CC(m)* is the *cyclomatic complexity* of the method *m*
//
// • and *cov(m)* is the *percentage coverage* by tests of the method *m*
//
// Matched methods cumulates two highly *error prone* code smells:
//
// • A complex method, difficult to develop and maintain.
//
// • Non 100% covered code, difficult to refactor without introducing any regression bug.
//
// The highest the CRAP score, the more painful to maintain and error prone is the method.
//
// An arbitrary threshold of 30 is fixed for this code rule as suggested by inventors.
//
// Notice that no amount of testing will keep methods with a Cyclomatic Complexity
// highest than 30, out of CRAP territory.
//
// Notice that this rule doesn't match too short method
// with less than 10 lines of code.
//</Description>

//<HowToFix>
// In such situation, it is recommended to both refactor the complex method logic
// into several smaller and less complex methods 
// (that might belong to some new types especially created),
// and also write unit-tests to full cover the refactored logic. 
//
// You'll find code impossible to cover by unit-tests, like calls to *MessageBox.Show()*.
// An infrastructure must be defined to be able to *mock* such code at test-time.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Complex methods partially covered by tests should be 100% covered</Name>

warnif count > 0 from m in JustMyCode.Methods 
 where 
     // These metrics' definitions are available here: 
     // http://www.ndepend.com/docs/code-metrics#MetricsOnMethods
     (  m.NbLinesOfCode > 30 || 
        m.CyclomaticComplexity > 20 || 
        m.NestingDepth > 4 || 
        m.NbVariables > 8) && 

     // Take care only of complex methods 
     // already partially covered, but not completely covered.
     m.PercentageCoverage > 0 &&
     m.PercentageCoverage < 100

  orderby m.NbLinesOfCodeNotCovered ascending,
          m.NbLinesOfCode descending
select new { m, m.PercentageCoverage, m.NbLinesOfCode, 
             m.NbLinesOfCodeCovered, m.NbLinesOfCodeNotCovered, 
             m.CyclomaticComplexity, m.NestingDepth, m.NbVariables }

//<Description>
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// There are default rules that warn about complex methods to refactor.
// The present rule warns about complex methods that are already a bit covered by tests
// but not 100% covered by tests.
//
// Such situation cumulates two highly *error prone* code smells:
//
// • A complex method, difficult to develop and maintain.
//
// • Non 100% covered code, difficult to refactor without creating any regression bug.
//
// Because the complex method is already covered partially by tests,
// it might be not so costly to write more tests to full cover it.
//</Description>

//<HowToFix>
// In such situation, it is recommended to both:
//
// • refactor the complex method logic
// into several smaller and less complex methods 
// (that might belong to some new types especially created),
//
// • and also write more unit-tests to full cover the refactored logic. 
//
// You'll find code impossible to cover by unit-tests, like calls to *MessageBox.Show()*.
// An infrastructure must be defined to be able to *mock* such code at test-time.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Method changed poorly covered</Name>
warnif count > 0
from m in Application.Methods where 
  m.PercentageCoverage < 30 && 
  m.CodeWasChanged() 
  orderby m.NbLinesOfCode descending, 
           m.NbLinesOfCodeNotCovered ,
           m.PercentageCoverage
select new { m, m.PercentageCoverage, m.NbLinesOfCode, 
             m.NbLinesOfCodeNotCovered }  

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
// This rule operates only on methods added or refactored since the baseline.
//
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// It is important to write code mostly covered by tests 
// to achieve *maintainable* and *non-error-prone* code.
//
// In real-world, many code bases are poorly covered by tests.
// However it is not practicable to stop the development for months
// to refactor and write tests to achieve high code coverage ratio.
//
// Hence it is recommended that each time a method (or a type) gets refactored,
// the developer takes the time to write associated unit-tests to cover it.
//
// Doing so will help to increase significantly the maintainability of the code base.
// You'll notice that quickly, refactoring will also be driven by testability, 
// and as a consequence, the overall code structure and design will increase as well.
//</Description>

//<HowToFix>
// Write unit-tests to cover the code of most methods and classes refactored.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Method added poorly covered</Name>
warnif count > 0
from m in Application.Methods where
  m.NbLinesOfCode > 0 &&
  m.PercentageCoverage < 30 && 
  m.WasAdded() 
  orderby m.NbLinesOfCode descending, 
           m.NbLinesOfCodeNotCovered ,
           m.PercentageCoverage
select new { m, m.PercentageCoverage, m.NbLinesOfCode, 
             m.NbLinesOfCodeNotCovered }

//<Description>
// This rule is executed only if a *baseline for comparison* is defined (*diff mode*).
// This rule operates only on methods added or refactored since the baseline.
//
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// It is important to write code mostly covered by tests 
// to achieve *maintainable* and *non-error-prone* code.
//
// In real-world, many code bases are poorly covered by tests.
// However it is not practicable to stop the development for months
// to refactor and write tests to achieve high code coverage ratio.
//
// Hence it is recommended that each time a method (or a type) gets added,
// the developer takes the time to write associated unit-tests to cover it.
//
// Doing so will help to increase significantly the maintainability of the code base.
// You'll notice that quickly, refactoring will also be driven by testability, 
// and as a consequence, the overall code structure and design will increase as well.
//</Description>

//<HowToFix>
// Write unit-tests to cover the code of most methods and classes added.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types 95% to 99% covered</Name>
warnif count > 0
from t in Application.Types where 
  t.PercentageCoverage >= 95 && 
  t.PercentageCoverage <= 99 &&
 !t.IsGeneratedByCompiler

  let methodsCulprit = t.Methods.Where(m => m.PercentageCoverage < 100)

  orderby t.NbLinesOfCode descending , 
           t.NbLinesOfCodeNotCovered ,
           t.PercentageCoverage
select new { t, t.PercentageCoverage, t.NbLinesOfCode, 
             t.NbLinesOfCodeNotCovered, methodsCulprit } 

//<Description>
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// Often covering the few percents of remaining uncovered code of a class, 
// requires as much work as covering the first 90%.
// For this reason, often teams estimate that 90% coverage is enough.
// However *untestable code* usually means *poorly written code* 
// which usually leads to *error prone code*.
// So it might be worth refactoring and making sure to cover the few uncovered lines of code
// **because most tricky bugs might come from this small portion of hard-to-test code**.
//
// Not all classes should be 100% covered by tests (like UI code can be hard to test)
// but you should make sure that most of the logic of your application
// is defined in some *easy-to-test classes*, 100% covered by tests.
//</Description>

//<HowToFix>
// Write more unit-tests dedicated to cover code not covered yet.
// If you find some *hard-to-test code*, it is certainly a sign that this code
// is not *well designed* and hence, needs refactoring.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces 95% to 99% covered</Name>
warnif count > 0
from n in Application.Namespaces where 
  n.PercentageCoverage >= 95 && 
  n.PercentageCoverage <= 99 

  let methodsCulprit = n.ChildMethods.Where(m => m.PercentageCoverage < 100)

  orderby n.NbLinesOfCode descending , 
           n.NbLinesOfCodeNotCovered ,
           n.PercentageCoverage
select new { n, n.PercentageCoverage, n.NbLinesOfCode, 
             n.NbLinesOfCodeNotCovered, methodsCulprit  } 

//<Description>
// This rule is executed only if some code coverage data is imported
// from some code coverage files.
//
// Often covering the few percents of remaining uncovered code of 
// one or several classes in a namespace
// requires as much work as covering the first 90%.
// For this reason, often teams estimate that 90% coverage is enough.
// However *untestable code* usually means *poorly written code* 
// which usually leads to *error prone code*.
// So it might be worth refactoring and making sure to cover the few uncovered lines of code
// **because most tricky bugs might come from this small portion of hard-to-test code**.
//
// Not all classes should be 100% covered by tests (like UI code can be hard to test)
// but you should make sure that most of the logic of your application
// is defined in some *easy-to-test classes*, 100% covered by tests.
//</Description>

//<HowToFix>
// Write more unit-tests dedicated to cover code not covered yet in the namespace.
// If you find some *hard-to-test code*, it is certainly a sign that this code
// is not *well designed* and hence, needs refactoring.
//</HowToFix>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types not covered at all</Name>
from t in Application.Types where 
  t.PercentageCoverage == 0
  orderby t.NbLinesOfCode descending
select new { t, t.NbLinesOfCode }

//<Description>
// This query is executed only if some code coverage data is imported
// from some code coverage files.
//
// This code query lists types not covered at all by any test.
//
// Often, when code is not covered at all by test, one can reach
// decent coverage ratio (like 50% to 90%) just by writing a few tests.
//
// The idea is not to cover code for the sake of it.
// The idea is that thanks to a small effort of writing a few tests,
// one can continuously check, that a significant portion of code 
// runs without a problem. 
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces not covered at all</Name>
from n in Application.Namespaces where 
  n.PercentageCoverage == 0
  orderby n.NbLinesOfCode descending
select new { n, n.NbLinesOfCode} 

//<Description>
// This query is executed only if some code coverage data is imported
// from some code coverage files.
//
// This code query lists namespaces not covered at all by any test.
//
// Often, when code is not covered at all by test, one can reach
// decent coverage ratio (like 50% to 90%) just by writing a few tests.
//
// The idea is not to cover code for the sake of it.
// The idea is that thanks to a small effort of writing a few tests,
// one can continuously check, that a significant portion of code 
// runs without a problem. 
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Test Methods</Name>

let testAttr = ThirdParty.Types.WithNameIn("TestAttribute", "TestCaseAttribute")
let testMethods = Methods.TaggedWithAnyAttributes(testAttr)
from m in testMethods 
select m

//<Description>
// We advise to not include test assemblies in code analyzed by NDepend.
// We estimate that it is acceptable and practical to lower the quality gate of test code,
// because the important measures for tests are:
//
// • The coverage ratio, 
//
// • And the amount of logic results asserted: This includes both
// assertions in test code, and assertions in code covered by tests, 
// like *Code Contract* assertions and *Debug.Assert(…)* assertions.
//
// But if you wish to enforce the quality of test code, you'll need to 
// consider test assemblies in your list of application assemblies 
// analyzed by NDepend.
//
// In such situation, this code query lists tests methods and you can 
// reuse this code in custom rules.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods directly called by test Methods</Name>

let testAttr = ThirdParty.Types.WithNameIn("TestAttribute", "TestCaseAttribute")
let testMethods = Methods.TaggedWithAnyAttributes(testAttr).ToHashSet()

// --- Uncomment this line if your test methods are in dedicated test assemblies ---
//let testAssemblies = testMethods.ParentAssemblies().ToHashSet()

from m in Application.Methods.UsedByAny(testMethods)

// --- Uncomment this line if your test methods are in dedicated test assemblies ---
//where !testAssemblies.Contains(m.ParentAssembly)

select new { m , 
             calledByTests = m.MethodsCallingMe.Intersect(testMethods ),
             // --- Uncomment this line if your project import some coverage data ---
             // m.PercentageCoverage 
}


//<Description>
// This query lists all methods directly called by tests methods.
// Overrides of virtual and abstract methods, called through polymorphism, are not listed.
// Methods solely invoked through a delegate are not listed.
// Methods solely invoked through reflection are not listed.
//
// We advise to not include test assemblies in code analyzed by NDepend.
// We estimate that it is acceptable and practical to lower the quality gate of test code,
// because the important measures for tests are:
//
// • The coverage ratio, 
//
// • And the amount of logic results asserted: This includes both
// assertions in test code, and assertions in code covered by tests, 
// like *Code Contract* assertions and *Debug.Assert(…)* assertions.
//
// But if you wish to run this code query,
// you'll need to consider test assemblies in your list of 
// application assemblies analyzed by NDepend.
//</Description>]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods directly and indirectly called by test Methods</Name>

let testAttr = from t in ThirdParty.Types.WithNameIn("TestAttribute", "TestCaseAttribute") select t
let testMethods = Methods.TaggedWithAnyAttributes(testAttr)

// --- Uncomment this line if your test methods are in dedicated test assemblies ---
// let testAssemblies = testMethods.ParentAssemblies().ToHashSet()

let depthOfCalledByTest = Application.Methods.DepthOfIsUsedByAny(testMethods)
from pair in depthOfCalledByTest
where pair.Value > 0 
orderby pair.Value ascending
// --- Uncomment this line if your test methods are in dedicated test assemblies ---
//&& !testAssemblies.Contains(pair.CodeElement.ParentAssembly)

select new { 
  method = pair.CodeElement, 
  // (depthOfCalledByTests == 1) means that the method is directly called by tests
  // (depthOfCalledByTests == 2) means that the method is directly called by a method directly called by tests
  // …
  depthOfCalledByTests = pair.Value,
  nbLinesOfCode = pair.CodeElement.NbLinesOfCode,
  // --- Uncomment this line if your project import some coverage data ---
  // m.PercentageCoverage
}

//<Description>
// This query lists all methods *directly or indirectly* called by tests methods.
// *Indirectly* called by a test means that a test method calls a method, that calls a method…
// From this recursion, a code metric named *depthOfCalledByTests* is inferred,
// The value *1* means directly called by test,
// the value *2* means called by a method that is called by a test…
//
// Overrides of virtual and abstract methods, called through polymorphism, are not listed.
// Methods solely invoked through a delegate are not listed.
// Methods solely invoked through reflection are not listed.
//
// We advise to not include test assemblies in code analyzed by NDepend.
// We estimate that it is acceptable and practical to lower the quality gate of test code,
// because the important measures for tests are:
//
// • The coverage ratio, 
//
// • And the amount of logic results asserted: This includes both
// assertions in test code, and assertions in code covered by tests, 
// like *Code Contract* assertions and *Debug.Assert(…)* assertions.
//
// But if you wish to run this code query,
// you'll need to consider test assemblies in your list of 
// application assemblies analyzed by NDepend.
//</Description>]]></Query>
    </Group>
    <Group Name="Dead Code" Active="True" ShownInReport="True">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Potentially dead Types</Name>
warnif count > 0

let tt=Types.UsedByAny(Application.Methods).ToHashSet()
// Select types unused
let typesUnused = 
   from t in JustMyCode.Types where
   t.NbTypesUsingMe == 0 && !t.IsGlobal  select t



from t in typesUnused  where !tt.Contains(t)
select new { t }
        
        ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Potentially dead Methods</Name>
warnif count > 0
// Filter procedure for methods that should'nt be considered as dead
let canMethodBeConsideredAsDeadProc = new Func<IMethod, bool>(
    m => !m.IsPublic &&       // Public methods might be used by client applications of your Projects.
         !m.IsEntryPoint &&            // Main() method is not used by-design.
         !m.IsClassConstructor &&      
         !m.IsVirtual &&               // Only check for non virtual method that are not seen as used in IL.
         !(m.IsConstructor &&          // Don't take account of protected ctor that might be call by a derived ctors.
           m.IsProtected) &&
         !m.NameLike (@"^On") &&        //Exclude Events like MFC ones
         !m.IsGeneratedByCompiler
)

// Get methods unused
let methodsUnused = 
   from m in JustMyCode.Methods where 
   m.NbMethodsCallingMe == 0 && 
   canMethodBeConsideredAsDeadProc(m)
   select m

// Dead methods = methods used only by unused methods (recursive)
let deadMethodsMetric = methodsUnused.FillIterative(
   methods => // Unique loop, just to let a chance to build the hashset.
              from o in new[] { new object() }
              // Use a hashet to make Intersect calls much faster!
              let hashset = methods.ToHashSet()
              from m in codeBase.Application.Methods.UsedByAny(methods).Except(methods)
              where canMethodBeConsideredAsDeadProc(m) &&
                    // Select methods called only by methods already considered as dead
                    hashset.Intersect(m.MethodsCallingMe).Count() == m.NbMethodsCallingMe
              select m)

from m in JustMyCode.Methods.Intersect(deadMethodsMetric.DefinitionDomain)
select new { m, m.MethodsCallingMe, depth = deadMethodsMetric[m] }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Potentially dead Fields</Name>
warnif count > 0
from f in JustMyCode.Fields where
   f.NbMethodsUsingMe == 0 && 
   !f.IsPublic &&     // Although not recommended, public fields might be used by client applications of your Projects.
   !f.IsEnumValue   
  
   // If you don't want to link CppDepend.API.dll, you can use your own IsNotDeadCodeAttribute and adapt this rule.
select f]]></Query>
    </Group>
    <Group Name="Modernize C++ Code (You must enable this feature to have results)" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Use auto specifier</Name>
 from issue in Issues where issue.ToolName=="Modernize" 
&& issue.Type=="auto"
select new { issue,issue.FilePath,Line=issue.BeginLine }
//This query search for places to use the auto type specifier 
//for variable declarations to improve code readability and maintainability.
//For more details you can refer to http://clang.llvm.org/extra/UseAutoTransform.html      

//N.B.: The Modernize feature must be enabled to have result. 
//You can enable it from "Project properties"=> Analysis=>Modernize C++ Code.
//However, it will take more time to analyse your code base/
//And it's recommended to disable it as soon as you no longer need its results. 

         ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Use nullptr</Name>
 from issue in Issues where issue.ToolName=="Modernize" 
&& issue.Type=="null"
select new { issue,issue.FilePath,Line=issue.BeginLine }
//This query search for the null pointer constants (eg. NULL, 0) 
//to replace with the new C++11 nullptr keyword.
//For more details you can refer to http://clang.llvm.org/extra/UseNullptrTransform.html      

//N.B.: The Modernize feature must be enabled to have result. 
//You can enable it from "Project properties"=> Analysis=>Modernize C++ Code.
//However, it will take more time to analyse your code base/
//And it's recommended to disable it as soon as you no longer need its results. 

       ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Modernize loops</Name>
 from issue in Issues where issue.ToolName=="Modernize" 
&& issue.Type=="loop"
select new { issue,issue.FilePath,Line=issue.BeginLine }

//This query searh for loops like for(...; ...; ...)  
//to use the new range-based loops in C++11. 
//For more details you can refer to http://clang.llvm.org/extra/LoopConvertTransform.html
       
//N.B.: The Modernize feature must be enabled to have result. 
//You can enable it from "Project properties"=> Analysis=>Modernize C++ Code.
//However, it will take more time to analyse your code base/
//And it's recommended to disable it as soon as you no longer need its results. 
         
         ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Use unique_ptr instead of auto_ptr</Name>
 from issue in Issues where issue.ToolName=="Modernize" 
&& issue.Type=="autoptr"
select new { issue,issue.FilePath,Line=issue.BeginLine }

//This query searh for the uses of the deprecated class std::auto_ptr
//to replace by std::unique_ptr . 
//For more details you can refer to http://clang.llvm.org/extra/ReplaceAutoPtrTransform.html

//N.B.: The Modernize feature must be enabled to have result. 
//You can enable it from "Project properties"=> Analysis=>Modernize C++ Code.
//However, it will take more time to analyse your code base/
//And it's recommended to disable it as soon as you no longer need its results. 
         
         
         ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Use override keyword</Name>
 from issue in Issues where issue.ToolName=="Modernize" 
&& issue.Type=="override"
select new { issue,issue.FilePath,Line=issue.BeginLine }
//This query search for places where you can add the override specifier 
//to member functions that override a virtual function
//in a base class and that don’t already have the specifier
//For more details you can refer to http://clang.llvm.org/extra/AddOverrideTransform.html   

//N.B.: The Modernize feature must be enabled to have result. 
//You can enable it from "Project properties"=> Analysis=>Modernize C++ Code.
//However, it will take more time to analyse your code base/
//And it's recommended to disable it as soon as you no longer need its results. 
             
         ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Pass By Value</Name>
 from issue in Issues where issue.ToolName=="Modernize" 
&& issue.Type=="byvalue"
select new { issue,issue.FilePath,Line=issue.BeginLine }

//This query search places where you can use the pass-by-value idiom.
//For more details you can refer to http://clang.llvm.org/extra/PassByValueTransform.html      

//N.B.: The Modernize feature must be enabled to have result. 
//You can enable it from "Project properties"=> Analysis=>Modernize C++ Code.
//However, it will take more time to analyse your code base
//And it's recommended to disable it as soon as you no longer need its results. 

              
     ]]></Query>
    </Group>
    <Group Name="Visibility" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Fields should be declared as private</Name>
warnif count > 0 from f in Application.Fields where 
 !f.IsPrivate && 

 // These conditions filter cases where fields 
 // doesn't represent state that should be encapsulated. 
 !f.IsGeneratedByCompiler && 
 !f.IsEnumValue
select new { f }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Constructors of abstract classes should be declared as protected or private</Name>
// Constructors of an abstract class can only be accessed from this class and derived class.
// Declaring such a constructor with another visibility level is useless and potentially misleading.

warnif count > 0
from t in Application.Types where 
  t.IsClass && 
  t.IsAbstract
let ctors = t.Constructors.Where(c => !c.IsProtected && !c.IsPrivate)
where ctors.Count() > 0
select new { t, ctors }

// Notice that if a constructor of an abstract class is declared as private,
// it can only be accessed from derived classes nested in the abstract class.]]></Query>
    </Group>
    <Group Name="Purity - Immutability - Constness" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Structures should be immutable</Name>
warnif count > 0 from t in Application.Types where 
   t.IsStructure && 
  !t.IsImmutable

let mutableFields = t.Fields.Where(f => !f.IsImmutable)

select new { t, t.NbLinesOfCode, mutableFields }

// It is deemed as a good practice to make 
// your structure immutable.
// An object is immutable if its state doesn’t 
// change once the object has been created. 
// Consequently, a structure is immutable if 
// its instances are immutable.
// Immutable types naturally simplify code by 
// limiting side-effects.
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid static fields with a mutable field type</Name>
warnif count > 0
from f in Application.Fields
where f.IsStatic && !f.IsEnumValue && !f.IsGeneratedByCompiler
let fieldType = f.FieldType
where fieldType != null && 
     !fieldType.IsThirdParty && 
     !fieldType.IsInterface && 
     !fieldType.IsImmutable
select new { f, 
             mutableFieldType = fieldType , 
             isFieldImmutable = f.IsImmutable }


]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>A field must not be assigned from outside its parent hierarchy types</Name>
warnif count > 0
from f in JustMyCode.Fields.Where(f => 
      !f.IsPrivate && !f.IsGeneratedByCompiler && 
      !f.IsImmutable && !f.IsEnumValue)

let methodsAssignerOutsideOfMyType = f.MethodsAssigningMe.Where(
        m =>!m.IsGeneratedByCompiler &&
             m.ParentType != f.ParentType && 
            !m.ParentType.DeriveFrom(f.ParentType) )

where methodsAssignerOutsideOfMyType.Count() > 0
select new { f, methodsAssignerOutsideOfMyType }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Use const_cast carefully</Name>
warnif count >0 (from m in Methods where m.IsUsing ("Keywords.const_cast")
select new { m, m.NbLinesOfCode }).Take(10)
          ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Use mutable variable carefully</Name>
warnif count >0  (from f in Fields where f.IsMutable
select new { f }).Take(10)
          ]]></Query>
    </Group>
    <Group Name="Naming Conventions" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Instance fields should be prefixed with a 'm_'</Name>
warnif count > 0 (from f in Fields where 
  !f.NameLike (@"^m_") && 
  !f.IsStatic  
  // Don't hesitate to customize the regex of NameLike to your preference. 
 && !f.IsGlobal && !f.IsEnumValue && !f.IsThirdParty 
select new { f }).Take(10)
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Static fields should be prefixed with a 's_'</Name>
   warnif count > 0 (from f in Fields where 
  !f.NameLike (@"^s_") && 
  f.IsStatic && !f.IsThirdParty 
  select new { f }).Take(10)  
  // Don't hesitate to customize the regex of NameLike to your preference.


]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Exception class name should be suffixed with 'Exception'</Name>
warnif count > 0 (from t in Types where t.IsExceptionClass && !t.NameLike (@"Exception$") && !t.IsThirdParty
select new { t, t.NbLinesOfCode }).Take(10)
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types name should begin with an Upper character</Name>
warnif count > 0 (from t in Types where 
 !t.NameLike (@"^[A-Z]")      // The name of a type should begin with an Upper letter.
  && // Except if it is generated by compiler or ...
 !t.IsThirdParty && !t.IsGlobal
select new { t, t.NbLinesOfCode }).Take(10)

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid types with name too long</Name>
warnif count > 0 from t in Application.Types 
where !t.IsGeneratedByCompiler && !t.IsThirdParty

where t.SimpleName.Length > 35 
select new { t, t.SimpleName }

      ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid methods with name too long</Name>
warnif count > 0 from m in Application.Methods where 
 !m.IsGeneratedByCompiler 
  && m.SimpleName.Length > 35 && !m.IsThirdParty

select new { m, m.SimpleName }

// The regex matches methods with name longer 
// than 35 characters.
// Method Name doesn't contain the type and namespace 
// prefix, FullName does.
// The regex computes the method name length from 
// the beginning until the first open parenthesis 
// or first lower than (for generic methods).
      ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid fields with name too long</Name>
warnif count > 0 from f in Application.Fields where
 !f.IsGeneratedByCompiler &&
  f.Name.Length > 35 && !f.IsThirdParty
select f

// The regex matches fields with name longer 
// than 35 characters.
// Field Name doesn't contain the type and 
// namespace prefix, FullName does.
      ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid naming types and namespaces with the same identifier</Name>

// Not only this can provoke compiler resolution collision,
// but also, this makes code less maintainable because
// concepts are not concisely identified.

warnif count > 0
let hashsetShortNames = Namespaces.Where(n => n.Name.Length > 0).Select(n => n.SimpleName).ToHashSet()

from t in JustMyCode.Types
where hashsetShortNames.Contains(t.Name) && !t.IsThirdParty
select new { t, namespaces = Namespaces.Where(n => n.SimpleName == t.Name) }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespace name should correspond to file location</Name>

// For a good code organization, 
// do mirror the namespaces hierarchy and the source files directories tree.

warnif count > 0
from n in Application.Namespaces 

// Replace dots by spaces in namespace name
let dirCorresponding = n.Name.Replace('.', ' ')

// Look at source file decl of JustMyCode type's declared in n
from t in n.ChildTypes
where JustMyCode.Contains(t) 
from decl in t.SourceDecls
let sourceFilePath = decl.SourceFile.FilePath.ToString()

// Replace dots and path separators by spaces in source files names
where !sourceFilePath.Replace('.',' ').Replace('\\',' ').Contains(dirCorresponding) && !t.IsThirdParty

select new { t, dirCorresponding , sourceFilePath  } ]]></Query>
    </Group>
    <Group Name="Source Files Organization" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Avoid defining multiple types in a source file</Name>
warnif count > 0 

// Build a lookup indexed by source files, values being a sequence of types defined in the source file.
let lookup = Application.Types.Where(t => 
                                !t.IsGlobal && 
                               // except nested types and types generated by compilers!
                               !t.IsGeneratedByCompiler &&                               
                               !t.IsNested)                                
                         // It could make sense to not apply this rule for enumerations.
                         // && !t.IsEnumeration)

            // We use multi-key, since a type can be declared in multiple source files.
           .ToMultiKeyLookup(t => t.SourceDecls.Select(d => d.SourceFile))
 
from @group in lookup where @group.Count() > 1
   let sourceFile = @group.Key

   // CQLinq doesn't let indexing result with sourceFile 
   // so we choose a typeIndex in types, 
   // preferably the type that has the file name.
   let typeWithSourceFileName = @group.FirstOrDefault(t => t.SimpleName == sourceFile.FileNameWithoutExtension)
   let typeIndex = typeWithSourceFileName ?? @group.First()

select new { typeIndex, 
             types = @group as IEnumerable<IType>, 
             sourceFile.FilePathString }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespace name should correspond to file location</Name>

// For a good code organization, 
// do mirror the namespaces hierarchy and the source files directories tree.

warnif count > 0
from n in Application.Namespaces 

// Replace dots by spaces in namespace name
let dirCorresponding = n.Name.Replace('.', ' ')

// Look at source file decl of JustMyCode type's declared in n
from t in n.ChildTypes
where JustMyCode.Contains(t) && !t.IsGlobal
from decl in t.SourceDecls
let sourceFilePath = decl.SourceFile.FilePath.ToString()

// Replace dots and path separators by spaces in source files names
where !sourceFilePath.Replace('.',' ').Replace('\\',' ').Contains(dirCorresponding)

select new { t, dirCorresponding , sourceFilePath  } ]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types with source files stored in the same directory, should be declared in the same namespace</Name>
warnif count > 0 

// Group JustMyCode types in a lookup 
// where groups are keyed with directories that contain the types' source file(s).
// Note that a type can be contained in several groups 
// if it is declared in several source files stored in different directories.
let lookup = JustMyCode.Types.Where(t => !t.IsGlobal)
            .ToMultiKeyLookup(
               t => t.SourceDecls.Select(
                          decl => decl.SourceFile.FilePath.ParentDirectoryPath).Distinct()
            )


from groupOfTypes in lookup
let parentNamespaces = groupOfTypes.ParentNamespaces()

// Select group of types (with source files stored in the same directory) ...
// ... but contained in several namespaces
where parentNamespaces.Count() > 1

// mainNamespaces is the namespace that contains many types 
// declared in the directory groupOfTypes .key
let mainNamespace  = groupOfTypes
                     .ToLookup(t => t.ParentNamespace)
                     .OrderByDescending(g => g.Count()).First().Key

// Select types with source files stored in the same directory,
// but contained in namespaces different than mainNamespace.
let typesOutOfMainNamespace = groupOfTypes
                              .Where(t => t.ParentNamespace != mainNamespace )

                               // Filter types declared on several source files that contain generated methods 
                               // because typically such type contains one or several partial definitions generated.
                               // These partially generated types would be false positive for the present rule.
                               .Where(t => t.SourceDecls.Count() == 1 ||
                                           t.Methods.Count(m => JustMyCode.Contains(m)) == 0)
where typesOutOfMainNamespace.Count() > 0

select new { mainNamespace, 

             // Typically a type in typesOutOfMainNamespace ...
             // 1) ... is contained in the wrong namespace but its source file(s) is stored in the right directory.
             //      --> In such situation the type should be contained in mainNamespace.
             // 2) ... is contained in the right namespace but its source file(s) is stored in the wrong directory
             //      --> In such situation the source file of type must be moved to the parent namespace directory.
             // 3) ... is declared in multiple source files, stored in different directories.
             //      --> It would be preferable that all source files are stored in a single directory.
             typesOutOfMainNamespace   }

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types declared in the same namespace, should have their source files stored in the same directory</Name>
warnif count > 0 
from @namespace in Application.Namespaces

// Group types of @namespace in a lookup 
// where groups are keyed with directories that contain the types' source file(s).
// Note that a type can be contained in several groups 
// if it is declared in several source files stored in different directories.
let lookup = @namespace.ChildTypes.Where(t => !t.IsGlobal && JustMyCode.Contains(t))
            .ToMultiKeyLookup(
               t => t.SourceDecls.Select(
                          decl => decl.SourceFile.FilePath.ParentDirectoryPath).Distinct()
            )

// Are types of @namespaces declared in more than one directory?
where lookup.Count > 1

// Infer the main directory, preferably the one that has the same name as the namespace.
let dirs = lookup.Select(types => types.Key)
let mainDirNullable = dirs.Where(d => d.DirectoryName == @namespace.SimpleName).FirstOrDefault()
let mainDir = mainDirNullable ?? dirs.First()

// Types declared out of mainDir, are types in group of types declared in a directory different than mainDir!
let typesDeclaredOutOfMainDir = lookup.Where(types => types.Key != mainDir)
                                .SelectMany(types => types)
                                
                                // Filter types declared on several source files that contain generated methods 
                                // because typically such type contains one or several partial definitions generated.
                                // These partially generated types would be false positive for the present rule.
                                .Where(t => t.SourceDecls.Count() == 1 ||
                                            t.Methods.Count(m => JustMyCode.Contains(m)) == 0)

where typesDeclaredOutOfMainDir.Count() > 0

select new { @namespace, 

             // Typically a type in typesDeclaredOutOfMainDir ...
             // 1) ... is contained in the wrong namespace but its source file(s) is stored in the right directory.
             //      --> In such situation the type parent namespace should be the namespace corresponding to the directory.
             // 2) ... is contained in the right namespace but its source file(s) is stored in the wrong directory
             //      --> In such situation the type source file should be moved to mainDir.
             // 3) ... is declared in multiple source files, stored in different directories.
             //      --> It would be preferable that all source files are stored in a single directory.
             typesDeclaredOutOfMainDir , 

             mainDir = mainDir.ToString() }]]></Query>
    </Group>
    <Group Name="Visual Studio Analyzer Queries" Active="False" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>All VS Defects</Name>
warnif count>0          
from issue in Issues  where issue.ToolName=="Visual Studio Analyzer"
select new { issue,issue.FilePath,issue.BeginLine }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most Classes violating Visual Studio Analyzer rules</Name>
(from t in Types where t.Issues.Where(i=>i.ToolName=="Visual Studio Analyzer").Count()>0
orderby t.Issues.Count() descending
select new { t,nbIssues=t.Issues.Count() }).Take(100)

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most Methods violating Visual Studio Analyzer rules</Name>
(from m in Methods where m.Issues.Where(i=>i.ToolName=="Visual Studio Analyzer").Count()>0
orderby m.Issues.Count() descending
select new { m,nbIssues=m.Issues.Count() }).Take(100)]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most Project violating Visual Studio Analyzer rules</Name>
(from p in Projects where p.Issues.Where(i=>i.ToolName=="Visual Studio Analyzer").Count()>0
orderby p.Issues.Count() descending
select new { p,nbIssues=p.Issues.Count() }).Take(5)]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most Recurrent Visual Studio Analyzer defects</Name>
let groups = Application.Issues.Where(i=>i.ToolName=="Visual Studio Analyzer").GroupBy(t => t.Type)

from g in groups
orderby g.Count() descending
select new { issue=g.FirstOrDefault(),count=g.Count() }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Popular Methods violating Visual Studio Analyzer rules</Name>
(from m in Methods where m.Issues.Where(i=>i.ToolName=="Visual Studio Analyzer").Count()>0
orderby m.MethodsCallingMe.Count() descending
select new { m,NbCallingMethods= m.MethodsCallingMe }).Take(100)]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Popular Classes violating Visual Studio Analyzer rules</Name>
from t in Types where t.Issues.Where(i=>i.ToolName=="Visual Studio Analyzer").Count()>0
orderby t.TypesUsingMe.Count() descending
select new { t,ClassesUsingMe= t.TypesUsingMe}]]></Query>
    </Group>
    <Group Name="CPD Queries" Active="False" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>All CPD duplications</Name>
from issue in Issues  where issue.ToolName=="CPD"
select new { issue,issue.FilePath,issue.BeginLine }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most duplicated code lines</Name>
from issue in Issues  where issue.ToolName=="CPD"
orderby issue.NbDuplicationCopies descending
select new { issue,issue.NbDuplicationCopies }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Big duplications</Name>
from issue in Issues  where issue.ToolName=="CPD"
orderby issue.NbLinesCopied descending
select new { issue,issue.NbLinesCopied }]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Classes containing big duplication</Name>
(from t in Types where t.Issues.Where(i=>i.ToolName=="CPD" && i.NbLinesCopied>100).Count()>0
orderby t.Issues.Count() descending
select new { t }).Take(100)
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Classes containing Many duplications</Name>
(from t in Types where t.Issues.Where(i=>i.ToolName=="CPD" && i.NbDuplicationCopies>10).Count()>0
orderby t.Issues.Count() descending
select new { t }).Take(100)]]></Query>
    </Group>
    <Group Name="Statistics" Active="False" ShownInReport="False">
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used types (Rank)</Name>
(from t in Application.Types orderby t.Rank descending
 select new { t, t.Rank }).Take(50)

// TypeRank values are computed by applying 
// the Google PageRank  algorithm on the 
// graph of types' dependencies. Types with 
// high Rank are the most used ones.
// See the definition of the TypeRank metric here: 
// http://www.cppdepend.com/Metrics.aspx#TypeRank]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used methods (Rank)</Name>
(from m in Application.Methods orderby m.Rank descending
 select new { m, m.Rank }).Take(50)

// MethodRank values are computed by applying 
// the Google PageRank  algorithm on the graph of 
// methods' dependencies. Methods with high Rank 
// are the most used ones. See the definition of 
// the MethodRank metric here:
// http://www.cppdepend.com/Metrics.aspx#MethodRank]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used namespaces (#NamespacesUsingMe )</Name>
(from n in Namespaces orderby n.NbNamespacesUsingMe descending
 select new { n, n.NamespacesUsingMe }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used types (#TypesUsingMe )</Name>
(from t in Types orderby t.NbTypesUsingMe descending
 select new { t, t.TypesUsingMe }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Most used methods (#MethodsCallingMe )</Name>
(from m in Methods orderby m.NbMethodsCallingMe descending
 select new { m, m.MethodsCallingMe }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Namespaces that use many other namespaces (#NamespacesUsed )</Name>
(from n in Application.Namespaces orderby n.NbNamespacesUsed descending
 select new { n, n.NamespacesUsed }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Types that use many other types (#TypesUsed )</Name>
(from t in Application.Types orderby t.NbTypesUsed descending
 select new { t, t.TypesUsed }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Methods that use many other methods (#MethodsCalled )</Name>
(from m in Application.Methods orderby m.NbMethodsCalled descending
 select new { m, m.MethodsCalled }).Take(50)]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>High-level to low-level Projects (Level)</Name>
from a in Application.Projects orderby a.Level descending
select new { a, a.Level }

// Classify Projects by their Level values.
// See the definition of the projectLevel metric here:
// http://www.cppdepend.com/Metrics.aspx#Level]]></Query>
      <Query Active="False" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>High-level to low-level namespaces (Level)</Name>
from n in Application.Namespaces orderby n.Level descending
select new { n, n.Level }

// Classify namespaces by their Level values.
// See the definition of the NamespaceLevel metric here:
// http://www.cppdepend.com/Metrics.aspx#Level]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>High-level to low-level types (Level)</Name>
from t in Application.Types orderby t.Level descending
select new { t, t.Level }

// Classify types by their Level values.
// See the definition of the TypeLevel metric here:
// http://www.cppdepend.com/Metrics.aspx#Level]]></Query>
      <Query Active="True" DisplayList="False" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>High-level to low-level methods (Level)</Name>
from m in Application.Methods orderby m.Level descending
select new { m, m.Level }

// Classify methods by their Level values.
// See the definition of the MethodLevel metric here:
// http://www.cppdepend.com/Metrics.aspx#Level]]></Query>
    </Group>
    <Group Name="Samples of Custom rules" Active="False" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the project P1 is not using the project P2</Name>
warnif count > 0 from a in Application.Projects where 
  a.IsUsing ("P2".AllowNoMatch().MatchProject()) &&
  (a.Name == @"P1")
select a
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that the project P1 is only using the Projects P2 or P3</Name>
warnif count > 0 from a in Application.Projects where 
  ( !a.IsUsing ("P2".AllowNoMatch().MatchProject()) ||
    !a.IsUsing ("P3".AllowNoMatch().MatchProject()) ||
    a.ProjectsUsed.Count() != 2) // Must not be used more than 2 Projects 
&& 
  (a.Name == @"P1")
select new { a, a.ProjectsUsed }
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that only 3 Projects are using Project P</Name>
warnif count != 3 from a in Application.Projects where 
  a.IsUsing ("P".AllowNoMatch().MatchProject())
select a
]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that all methods that call Foo.Fct1() also call Foo.Fct2(Int32)</Name>
warnif count > 0 from m in Application.Methods where 
   m.IsUsing ("Foo.Fct1()".AllowNoMatch()) &&
  !m.IsUsing ("Foo.Fct2(Int32)".AllowNoMatch())
select m
]]></Query>
      <Group Name="Custom Naming Conventions" Active="False" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that all types that derive from Foo, has a name that ends up with Foo</Name>
warnif count > 0 from t in Application.Types where 
   t.DeriveFrom ("Foo".AllowNoMatch().MatchType()) &&
  !t.NameLike (@"Foo$")
select new { t, t.NbLinesOfCode }
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Check that all namespaces begins with CompanyName.ProductName</Name>
warnif count > 0 from n in Application.Namespaces where 
  !n.NameLike (@"^CompanyName.ProductName")
select new { n, n.NbLinesOfCode } ]]></Query>
      </Group>
    </Group>
    <Group Name="Trend Metrics" Active="True" ShownInReport="False">
      <Group Name="Code Size" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code" Unit="LoC" />  
Application.Projects.Sum(a => a.NbLinesOfCode)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code (JustMyCode)" Unit="LoC" />
JustMyCode.Methods.Sum(m => m.NbLinesOfCode)

// JustMyCode is defined by code queries prefixed with 'notmycode' 
// in the group 'Defining JustMyCode'.
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code (NotMyCode)" Unit="LoC" />
Application.Methods.Where(m => !JustMyCode.Contains(m))
                   .Sum(m => m.NbLinesOfCode)

// JustMyCode is defined by code queries prefixed with 'notmycode' 
// in the group 'Defining JustMyCode'.
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code Added since the Baseline" Unit="LoC" />  
( from a in Application.Projects
  let nbLocAdded = a.IsPresentInBothBuilds() ? 
                   a.NbLinesOfCode - (int)a.OlderVersion().NbLinesOfCode :
                   a.NbLinesOfCode
  select nbLocAdded)
.Sum(loc => loc)

// A value is computed by this Trend Metric query
// only if a Baseline for Comparison is provided.
// See Project Properties > Analysis > Baseline for Comparison
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Source Files" Unit="Source Files" />
Application.Projects.SelectMany(
  a => a.SourceDecls.Select(sd => sd.SourceFile.FilePathString.ToLower()))
.Distinct()
.Count()

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Comments" Unit="Lines" />  
Application.Projects.Sum(a => a.NbLinesOfComment)

// So far comments are only extracted from C# source code.
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Projects" Unit="Projects" />
Application.Projects.Count()

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Namespaces" Unit="Namespaces" />
Application.Namespaces.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Types" Unit="Types" />
Application.Types.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Classes" Unit="Types" />
Application.Types.Count(t => t.IsClass && !t.IsGeneratedByCompiler)
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Abstract Classes" Unit="Types" />
Application.Types.Count(t => t.IsClass && t.IsAbstract)

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Interfaces" Unit="Types" />
Application.Types.Count(t => t.IsInterface)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Structures" Unit="Types" />
Application.Types.Count(t => t.IsStructure)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Methods" Unit="Methods" />
Application.Methods.Count(m => !m.IsGeneratedByCompiler)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Abstract Methods" Unit="Methods" />
Application.Methods.Count(m => m.IsAbstract)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Concrete Methods" Unit="Methods" />
Application.Methods.Count(m => !m.IsAbstract && !m.IsGeneratedByCompiler)
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Fields" Unit="Fields" />
Application.Fields.Count(f => 
   !f.IsEnumValue && 
   !f.IsGeneratedByCompiler && 
   !f.ParentType.IsEnumeration)

]]></Query>
      </Group>
      <Group Name="Maximum and Average" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max # Lines of Code for Methods (JustMyCode)" Unit="LoC" />
JustMyCode.Methods
          .Max(m => m.NbLinesOfCode)
          .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the (JustMyCode) method with largest # Lines of Code
// JustMyCode.Methods.OrderByDescending(m => m.NbLinesOfCode).Take(1).Select(m => new {m, m.NbLinesOfCode})
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Lines of Code for Methods" Unit="LoC" />
Application.Methods.Where(m => m.NbLinesOfCode > 0)
                   .Average(m => m.NbLinesOfCode)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Lines of Code for Methods with at least 3 Lines of Code" Unit="LoC" />
Application.Methods.Where(m => m.NbLinesOfCode >= 3)
                   .Average(m => m.NbLinesOfCode)
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max # Lines of Code for Types (JustMyCode)" Unit="LoC" />
JustMyCode.Types
          .Max(t => t.NbLinesOfCode)
          .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the (JustMyCode) type with largest # Lines of Code
// JustMyCode.Types.OrderByDescending(t => t.NbLinesOfCode).Take(1).Select(t => new {t, t.NbLinesOfCode})

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Lines of Code for Types" Unit="LoC" />
Application.Types.Where(t => t.NbLinesOfCode > 0)
                 .Average(t => t.NbLinesOfCode)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max Cyclomatic Complexity for Methods" Unit="Paths" />
Application.Methods
          .Max(m => m.CyclomaticComplexity)
          .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the most complex method, according to Cyclomatic Complexity
// Application.Methods.OrderByDescending(m => m.CyclomaticComplexity).Take(1).Select(m => new {m, m.CyclomaticComplexity})
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max Cyclomatic Complexity for Types" Unit="Paths" />
Application.Types
          .Max(t => t.CyclomaticComplexity)
          .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the most complex method, according to Cyclomatic Complexity
// Application.Methods.OrderByDescending(m => m.CyclomaticComplexity).Take(1).Select(m => new {m, m.CyclomaticComplexity})
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average Cyclomatic Complexity for Methods" Unit="Paths" />
Application.Methods.Where(m => m.NbLinesOfCode> 0)
                   .Average(m => m.CyclomaticComplexity)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average Cyclomatic Complexity for Types" Unit="Paths" />
Application.Types.Where(t => t.NbLinesOfCode> 0)
                   .Average(t => t.CyclomaticComplexity)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max Nesting Depth for Methods" Unit="Scopes" />
Application.Methods
          .Max(m => m.NestingDepth)
          .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the method with highest NestingDepth.
// Application.Methods.OrderByDescending(m => m.NestingDepth).Take(1).Select(m => new {m, m.NestingDepth})
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average Nesting Depth for Methods" Unit="Scopes" />
Application.Methods.Average(m => m.NestingDepth)
]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max # of Methods for Types" Unit="Methods" />
Application.Types
           .Max(t => t.NbMethods) 
           .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the (JustMyCode) type with largest # of Methods
// JustMyCode.Types.OrderByDescending(t => t.NbMethods).Take(1).Select(t => new {t, t.Methods})

]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Methods for Types" Unit="Methods" />
Application.Types.Average(t => t.NbMethods)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max # of Methods for Interfaces" Unit="Methods" />
Application.Types.Where(t => t.IsInterface)
           .Max(t => t.NbMethods) 
           .ToEnumerable().Sum(loc => loc)

// Here is the code query to get the (JustMyCode) type with largest # of Methods
// JustMyCode.Types.OrderByDescending(t => t.NbMethods).Take(1).Select(t => new {t, t.Methods})]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average # Methods for Interfaces" Unit="Methods" />
JustMyCode.Types.Where(t => t.IsInterface)
                .Average(t => t.NbMethods)
]]></Query>
      </Group>
      <Group Name="Code Coverage" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Percentage Code Coverage" Unit="%" />
((float)Application.Projects.Sum(a => a.NbLinesOfCodeCovered) /
        Application.Projects.Sum(a => a.NbLinesOfCode)
 * 100f)
.ToEnumerable().Sum()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code Covered" Unit="LoC" />
Application.Projects.Sum(a => a.NbLinesOfCodeCovered)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code Not Covered" Unit="LoC" />
Application.Projects.Sum(a => a.NbLinesOfCodeNotCovered)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code in Types 100% Covered" Unit="LoC" />
Application.Types.Where(t => t.PercentageCoverage == 100)
           .Sum(t => t.NbLinesOfCodeCovered)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Lines of Code in Methods 100% Covered" Unit="LoC" />
Application.Methods.Where(m => m.PercentageCoverage == 100)
           .Sum(m => m.NbLinesOfCodeCovered)]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Max C.R.A.P Score" />

(from m in JustMyCode.Methods

// Don't match too short methods
where m.NbLinesOfCode > 10

let CC = m.CyclomaticComplexity
let uncov = (100 - m.PercentageCoverage) / 100f
let CRAP = (CC * CC * uncov * uncov * uncov) + CC
where CRAP != null && CRAP > 30 select CRAP)
.Max(CRAP => CRAP)

//<Description>
// **Change Risk Analyzer and Predictor** (i.e. CRAP) is a code metric
// that helps in pinpointing overly complex and untested code.
// Is has been first defined here: 
// http://www.artima.com/weblogs/viewpost.jsp?thread=215899
//
// The Formula is:  **CRAP(m) = CC(m)^2 * (1 – cov(m)/100)^3 + CC(m)**
//
// • where *CC(m)* is the *cyclomatic complexity* of the method *m*
//
// • and *cov(m)* is the *percentage coverage* by tests of the method *m*
//
// Matched methods cumulates two highly *error prone* code smells:
//
// • A complex method, difficult to develop and maintain.
//
// • Non 100% covered code, difficult to refactor without any regression bug.
//
// The highest the CRAP score, the more painful to maintain and error prone is the method.
//
// An arbitrary threshold of 30 is fixed for this code rule as suggested by inventors.
//
// Notice that no amount of testing will keep methods with a Cyclomatic Complexity
// highest than 30, out of CRAP territory.
//
// Notice that CRAP score is not computed for too short methods
// with less than 10 lines of code.
//
// To list methods with highest C.R.A.P scores, please refer to the default rule:
//   *Test and Code Coverage* > *C.R.A.P method code metric*
//</Description>]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="False" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="Average C.R.A.P Score" />

(from m in JustMyCode.Methods

// Don't match too short methods
where m.NbLinesOfCode > 10

let CC = m.CyclomaticComplexity
let uncov = (100 - m.PercentageCoverage) / 100f
let CRAP = (CC * CC * uncov * uncov * uncov) + CC
where CRAP != null && CRAP > 30 select CRAP)
.Average(CRAP => CRAP)

//<Description>
// **Change Risk Analyzer and Predictor** (i.e. CRAP) is a code metric
// that helps in pinpointing overly complex and untested code.
// Is has been first defined here: 
// http://www.artima.com/weblogs/viewpost.jsp?thread=215899
//
// The Formula is:  **CRAP(m) = CC(m)^2 * (1 – cov(m)/100)^3 + CC(m)**
//
// • where *CC(m)* is the *cyclomatic complexity* of the method *m*
//
// • and *cov(m)* is the *percentage coverage* by tests of the method *m*
//
// Matched methods cumulates two highly *error prone* code smells:
//
// • A complex method, difficult to develop and maintain.
//
// • Non 100% covered code, difficult to refactor without any regression bug.
//
// The highest the CRAP score, the more painful to maintain and error prone is the method.
//
// An arbitrary threshold of 30 is fixed for this code rule as suggested by inventors.
//
// Notice that no amount of testing will keep methods with a Cyclomatic Complexity
// highest than 30, out of CRAP territory.
//
// Notice that CRAP score is not computed for too short methods
// with less than 10 lines of code.
//
// To list methods with highest C.R.A.P scores, please refer to the default rule:
//   *Test and Code Coverage* > *C.R.A.P method code metric*
//</Description>]]></Query>
      </Group>
      <Group Name="Third-Party Usage" Active="True" ShownInReport="False">
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Projects Used" Unit="Projects" />
ThirdParty.Projects.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Namespaces Used" Unit="Namespaces" />
ThirdParty.Namespaces.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Types Used" Unit="Types" />
ThirdParty.Types.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Methods Used" Unit="Methods" />
ThirdParty.Methods.Count()]]></Query>
        <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <TrendMetric Name="# Third-Party Fields Used" Unit="Fields" />
ThirdParty.Fields.Count()]]></Query>
      </Group>
    </Group>
    <Group Name="Defining JustMyCode" Active="True" ShownInReport="False">
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Discard methods in a directory  from JustMyCode</Name>
notmycode from m in Methods.Where(a=>a.SourceDecls.FirstOrDefault()!=null && a.SourceDecls.FirstOrDefault().SourceFile.DirectoryPath.Contains("path to exclude"))
select m

]]></Query>
      <Query Active="True" DisplayList="True" DisplayStat="True" DisplaySelectionView="False" IsCriticalRule="False"><![CDATA[// <Name>Discard types in a directory  from JustMyCode</Name>
notmycode from t in Types.Where(a=>a.SourceDecls.FirstOrDefault()!=null && a.SourceDecls.FirstOrDefault().SourceFile.DirectoryPath.Contains("path to exclude"))
select t

]]></Query>
    </Group>
  </Queries></NDepend>