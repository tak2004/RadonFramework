#ifndef RF_THREADING_THREAD_HPP
#define RF_THREADING_THREAD_HPP
#if _MSC_VER > 1000
#pragma once
#endif

#include <RadonFramework/Core/Types/Bool.hpp>
#include <RadonFramework/Core/Types/Int64.hpp>
#include <RadonFramework/Core/Types/UInt8.hpp>
#include <RadonFramework/Core/Types/String.hpp>
#include <RadonFramework/System/Threading/Mutex.hpp>
#include <RadonFramework/Collections/AutoVector.hpp>
#include <RadonFramework/Memory/AutoPointer.hpp>
#include <RadonFramework/Threading/ThreadPriority.hpp>
#include <RadonFramework/Threading/ThreadError.hpp>
#include <RadonFramework/Collections/BitArray.hpp>
#include <RadonFramework/Time/TimeSpan.hpp>

namespace RadonFramework { namespace Time {

struct TimeSpan;

} }

namespace RadonFramework { namespace Threading {
            
class Thread
{
public:
    Thread();
    ~Thread();
    
    /// This method will start the thread.
    void Start();
    
    /// This method will stop the thread and wait till it's done.
    void Exit();
    
    /// This method will stop the thread and return immediately.
    void Interrupt();

    /// Return false if the thread is not alive or Exit/Interrupt was called else true.
    RF_Type::Bool ShouldRunning();

    /// Wait till the thread is dead.
    void Join();
    void Join(const RF_Time::TimeSpan& Delta);

    /// Return the thread priority.
    ThreadPriority::Type Priority();
    
    /// Set a new thread priority.
    void Priority(ThreadPriority::Type Value);
    
    /// Return the affinity mask.
    RF_Type::Bool GetAffinityMask(RF_Collect::BitArray<>& Mask)const;
    
    /// Set the affinity mask.
    RF_Type::Bool SetAffinityMask(const RF_Collect::BitArray<>& NewValue)const;

    /// Is the thread is running.
    RF_Type::Bool IsAlive();

    /// Return true if the backend is working.
    RF_Type::Bool Working();

    /// Assign a name to the thread, to make debugging easier.
    const RF_Type::String& Name()const;
    void Name(const RF_Type::String& NewName);

    /// ProcessID
    RF_Type::Int64 Pid()const;

    static void Sleep(const RF_Time::TimeSpan& Delta);
            
    /// Allocate memory and assign it to the Thread.
    /// If the tread die and the memory isn't freed till yet then it will
    /// be cleaned up by the destructor.
    void* MemAlloc(const RF_Type::UInt64 Bytes);
            
    /// Free allocated memory, if it was generated by an instance of this
    /// Thread class.
    void FreeMem(const void* Ptr);

    /// Return true if the pointer is part of the allocated memory of
    /// a Thread instances.
    RF_Type::Bool MemAccess(const void* Ptr);

    /// Return the Process ID of the current thread or main process.
    static RF_Type::Int64 CurrentPid();

    /// This function will be called from the dying thread.
    virtual void Finished();

    /// This function will be called from the thread to run multi threaded code.
    virtual void Run()=0;
protected:
    ThreadPriority::Type m_Priority;
    RF_Type::Bool m_Alive;
    RF_Type::Bool m_CreateSuccessful;
    RF_Collect::AutoVector<RF_Type::UInt8> m_ThreadAllocatedMemory;
    RF_SysThread::Mutex m_ThreadBarrier;
    RF_Type::String m_Name;
    RF_Type::Int64 m_Pid;
    void* m_ImplData;
};

} }

#ifndef RF_SHORTHAND_NAMESPACE_THREADING
#define RF_SHORTHAND_NAMESPACE_THREADING
namespace RF_Thread = RadonFramework::Threading;
#endif

#endif // RF_THREADING_THREAD_HPP
