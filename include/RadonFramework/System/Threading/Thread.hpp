#ifndef RF_SYSTEM_THREADING_THREAD_HPP
#define RF_SYSTEM_THREADING_THREAD_HPP
#if _MSC_VER > 1000
#pragma once
#endif

#include <RadonFramework/Core/Types/Bool.hpp>
#include <RadonFramework/Core/Types/Int64.hpp>
#include <RadonFramework/Core/Types/UInt8.hpp>
#include <RadonFramework/Core/Types/String.hpp>
#include <RadonFramework/System/Threading/Mutex.hpp>
#include <RadonFramework/Core/Pattern/Signal.hpp>
#include <RadonFramework/Collections/AutoVector.hpp>
#include <RadonFramework/Memory/AutoPointer.hpp>
#include <RadonFramework/Threading/ThreadPriority.hpp>
#include <RadonFramework/Threading/ThreadError.hpp>
#include <RadonFramework/Threading/IRunnable.hpp>
#include <RadonFramework/Collections/BitArray.hpp>
#include <RadonFramework/Time/TimeSpan.hpp>

namespace RadonFramework { namespace Time {

struct TimeSpan;

} }

namespace RadonFramework { namespace System { namespace Threading {
            
class Thread:public RadonFramework::Threading::IRunnable,public RF_Pattern::SignalReceiver
{
public:
    Thread();
    Thread(RadonFramework::Threading::IRunnable* Target);
    virtual ~Thread();
    
    /// The code in this method is executed by the thread.
    virtual void Run();
    
    /// This method will start the thread.
    void Start();
    
    /// This method will stop the thread and wait till it's done.
    void Exit();
    
    /// This method will stop the thread and return immediately.
    void Interrupt();

    /** Check if the thread was stopped by Exit() or Interrupt().
    * Use this in Run().
    **/
    void CheckCancel();

    /// Wait till the thread is dead.
    void Join();
    void Join(const RF_Time::TimeSpan& Delta);

    /// Return the thread priority.
    RF_Thread::ThreadPriority::Type Priority();
    
    /// Set a new thread priority.
    void Priority(RF_Thread::ThreadPriority::Type Value);
    
    /// Return the affinity mask.
    RF_Type::Bool GetAffinityMask(RF_Collect::BitArray<>& Mask)const;
    
    /// Set the affinity mask.
    RF_Type::Bool SetAffinityMask(const RF_Collect::BitArray<>& NewValue)const;

    /// Is the thread is running.
    RF_Type::Bool IsAlive();

    /// Return true if the backend is working.
    RF_Type::Bool Working();

    /// Assign a name to the thread, to make debugging easier.
    const RF_Type::String& Name()const;
    void Name(const RF_Type::String& NewName);

    /// ProcessID
    RF_Type::Int64 Pid()const;

    /// Will be called after the processing cursor left the Run methode scope.
    RF_Pattern::Signal OnFinished;

    static void Sleep(const RF_Time::TimeSpan& Delta);
            
    /// Allocate memory and assign it to the Thread.
    /// If the tread die and the memory isn't freed till yet then it will
    /// be cleaned up by the destructor.
    void* MemAlloc(const RF_Type::UInt64 Bytes);
            
    /// Free allocated memory, if it was generated by an instance of this
    /// Thread class.
    void FreeMem(const void* Ptr);

    /// Return true if the pointer is part of the allocated memory of
    /// a Thread instances.
    RF_Type::Bool MemAccess(const void* Ptr);

    /// Return the Process ID of the current thread or main process.
    static RF_Type::Int64 CurrentPid();
protected:
    RF_Thread::ThreadPriority::Type m_Priority;
    IRunnable* m_Target;
    RF_Type::Bool m_Alive;
    RF_Type::Bool m_CreateSuccessful;
    RF_Collect::AutoVector<RF_Type::UInt8> m_ThreadAllocatedMemory;
    Mutex m_ThreadBarrier;
    RF_Type::String m_Name;
    RF_Type::Int64 m_Pid;
    void* m_ImplData;
    void Finished();
};
        
} } }

#endif // RF_SYSTEM_THREADING_THREAD_HPP
